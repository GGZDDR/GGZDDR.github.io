<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>x86内核-保护模式--页 | ZDDR's blog</title><meta name="keywords" content="ZDDR,逆向,内核,Pwn"><meta name="author" content="ZDDR"><meta name="copyright" content="ZDDR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="101012分页模式配置我们默认的分页模式为29912分页模式，需要修改为101012分页模式。 将原本的debug启动项拷贝一份 1bcdedit &#x2F;copy &amp;#123;current&amp;#125; &#x2F;d 101012 ] 关闭DEP（数据执行保护） 1bcdedit &#x2F;set &amp;#123;dd64745e-0a47-11eb-bc4d-cd0e0677722b&amp;#125; nx AlwaysO">
<meta property="og:type" content="article">
<meta property="og:title" content="x86内核-保护模式--页">
<meta property="og:url" content="https://zddr.net/2020/10/29/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E9%A1%B5/index.html">
<meta property="og:site_name" content="ZDDR&#39;s blog">
<meta property="og:description" content="101012分页模式配置我们默认的分页模式为29912分页模式，需要修改为101012分页模式。 将原本的debug启动项拷贝一份 1bcdedit &#x2F;copy &amp;#123;current&amp;#125; &#x2F;d 101012 ] 关闭DEP（数据执行保护） 1bcdedit &#x2F;set &amp;#123;dd64745e-0a47-11eb-bc4d-cd0e0677722b&amp;#125; nx AlwaysO">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/11/1oFBM8.png">
<meta property="article:published_time" content="2020-10-28T16:00:00.000Z">
<meta property="article:modified_time" content="2020-11-17T16:00:00.000Z">
<meta property="article:author" content="ZDDR">
<meta property="article:tag" content="ZDDR,逆向,内核,Pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/02/11/1oFBM8.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zddr.net/2020/10/29/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E9%A1%B5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZDDR","link":"链接: ","source":"来源: ZDDR's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-18 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/ZDDR/blog_img/raw/master/img/index_img/%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.ax1x.com/2020/02/11/1oFBM8.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZDDR's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">x86内核-保护模式--页</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-28T16:00:00.000Z" title="发表于 2020-10-29 00:00:00">2020-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-17T16:00:00.000Z" title="更新于 2020-11-18 00:00:00">2020-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/windows%E5%86%85%E6%A0%B8/">windows内核</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="101012分页模式配置"><a href="#101012分页模式配置" class="headerlink" title="101012分页模式配置"></a>101012分页模式配置</h1><p>我们默认的分页模式为29912分页模式，需要修改为101012分页模式。</p>
<p>将原本的debug启动项拷贝一份</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /copy &#123;current&#125; /d 101012</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/10/30/BYANfP.png" alt="img">]</p>
<p>关闭<strong>DEP</strong>（数据执行保护）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> &#123;dd64745e-0a47-11eb-bc4d-cd0e0677722b&#125; nx AlwaysOff</span><br></pre></td></tr></table></figure>
<p>关闭<strong>PAE</strong>(物理扩展内存)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> &#123;dd64745e-0a47-11eb-bc4d-cd0e0677722b&#125; pae ForceDisale</span><br></pre></td></tr></table></figure>
<p>全部操作成功的话就可以看见这两项</p>
<p><img src="https://s1.ax1x.com/2020/10/30/BYAX6O.png" alt="img"></p>
<p>并且重启后数据执行保护功能变灰</p>
<p><img src="https://s1.ax1x.com/2020/10/30/BYErjO.png" alt="img"></p>
<p>并且DirBase以K为单位进行变动，说明101012分页模式开启成功</p>
<p><img src="https://s1.ax1x.com/2020/10/30/BYV4o9.png" alt="img"></p>
<p>windows7 x86的两种29912分页和101012分别由ntkrnlpa.exe和nroskrnl.exe两个内核文件进行管理。</p>
<h2 id="什么是分页模式？"><a href="#什么是分页模式？" class="headerlink" title="什么是分页模式？"></a>什么是分页模式？</h2><p>像29912或是101012这种分页模式的名字并不是cpu厂商起的，更不是操作系统厂商起的，只是为了好区分当前的分页模式。</p>
<p>为了更好的解释分页模式，这里先来一段汇编指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>
<p>众所周知，这里的0x12345678并不是线性地址（虚拟地址），而是一个逻辑地址（偏移）。</p>
<p>在正常的情况下，我们需要使用<strong>ds.base+逻辑地址</strong>才能转换得到真正的线性地址，只不过现在段的base都是0，就可以直接忽略掉他。</p>
<p><strong>ds.base+逻辑地址</strong>得到的这个线性地址在101012的分页模式下就会被拆成10、10、12这三段。</p>
<p>怎么拆呢？首先，将0x12345678转换为二进制得到 <code>0001 0010 0011 0100 0101 0110 0111 1000</code></p>
<p>0001 0010 0011 0100 0101 <code>0110 0111 1000</code></p>
<p>后面这三位其实不用拆成二进制，因为3x4=12，刚刚好。</p>
<p>这三位<code>678</code>称为<strong>页内偏移</strong></p>
<p>剩下<code>0001 0010 0011 0100 0101</code>这20位。</p>
<p>剩下的20位从右向左数10位进行分割得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0001 0010 00</span><br><span class="line">11 0100 0101</span><br></pre></td></tr></table></figure>
<p>不足4位的进行补0，得到：</p>
<p><code>0000 0100 1000</code> =0x48</p>
<p><code>0011 0100 0101</code> =0x345</p>
<p>拆份出来后，就可以通过这0x48、0x345、0x678这三个值来寻找到真正的物理地址。</p>
<p>在这，还要说明一个概念，就是一个页的大小为4096字节也就是4k，转换为16进制就是0x1000。</p>
<p>那么为什么是4096不能是别的数值呢？其实这就是根据<strong>页内偏移</strong>这后面三位决定的，后三位最大值为FFF，也就是4095，计算机都是从0开始算的，所以刚好是4096个，分页模式就是决定页大小为4096的原因。</p>
<h2 id="寻找物理地址"><a href="#寻找物理地址" class="headerlink" title="寻找物理地址"></a>寻找物理地址</h2><p>当知道线性地址是如何根据分页模式进行拆分之后，就可以根据线性地址得到真正的物理地址了。</p>
<p>打开<strong>notepad.exe</strong>输入一段文本，然后使用ce搜索出该文本的线性地址<code>0x00257FC0</code>。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/ce%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80.png" alt="ce"></p>
<p>根据上面的拆解可以知道后12位<code>FC0</code>为<strong>页内偏移</strong>不用拆，只需要拆前面的<code>0x00257</code>即可。</p>
<p>首先<code>0x00257</code>转换为二进制得到<code>10 0101 0111</code>按照4位将0补全得到<code>0000 0000 0000 0010 0101 0111</code></p>
<p>拆开得：</p>
<p><code>0000 0000 0000</code> =0</p>
<p><code>0010 0101 0111</code> =0x257</p>
<p>现在得到了三层偏移（为什么是三层偏移这个下一小节再说），因为每个页的大小都为4096字节，那么里面每个元素的大小只能为4字节，所以偏移地址要乘4，最终得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0*4</span><br><span class="line">0x257*4</span><br><span class="line">0xFC0</span><br></pre></td></tr></table></figure>
<p>接下来使用Windbg找到<strong>notepad.exe</strong>的<strong>页基址</strong>(CR3) <code>0x71de9000</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/notepad%E9%A1%B5%E5%9F%BA%E5%9D%80.png" alt="image-20201031145213470"></p>
<p>使用这个CR3加上刚刚的第一层偏移<code>0*4</code>得到<code>0x70da1867</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/cr3+0x4.png" alt="image-20201031145701177"></p>
<p>然后把<code>0x70da1867</code>的后三位去掉（因为这三位不是地址，是属性）,得到<code>0x70da1000</code>，再用这个地址加上第二层偏移<code>0x257*4</code>得到<code>0x71749867</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/257*4.png" alt="image-20201031150757342"></p>
<p>同样把<code>0x71749867</code>的后三位去掉，然后加上页内偏移<code>0xFC0</code>得到的就是文本内容的物理地址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E8%AE%B0%E4%BA%8B%E6%9C%AC%E5%86%85%E5%AD%98.png" alt="image-20201031151430973"></p>
<h2 id="三层偏移是什么东西？"><a href="#三层偏移是什么东西？" class="headerlink" title="三层偏移是什么东西？"></a>三层偏移是什么东西？</h2><p>在这先附上一张Intel白皮书一张名为<strong>Segmentation and Paging</strong>的图片，这张图片详细说明了一个内存地址的分割和分页的关系。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/Segmentation%20and%20Paging.png" alt="image-20201031162406822"></p>
<p>在线性地址转换的图中也清楚说明了101012分页怎么根据一个线性地址转换得到物理地址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="线性地址转换"></p>
<p>关于IA-32e模式下的内存管理也说明了各个表直接的关系</p>
<blockquote>
<p><strong>2.1.5.1 Memory Management in IA-32e Mode</strong><br>In IA-32e mode, physical memory pages are managed by a set of system data structures. In compatibility mode and 64-bit mode, four levels of system data structures are used. These include:</p>
<ul>
<li><strong>The page map level 4 (PML4)</strong> — An entry in a PML4 table contains the physical address of the base of a page directory pointer table, access rights, and memory management information. The base physical address of the PML4 is stored in CR3.</li>
<li><strong>A set of page directory pointer tables</strong> — An entry in a page directory pointer table contains the physical address of the base of a page directory table, access rights, and memory management information.</li>
<li><strong>Sets of page directories</strong> — An entry in a page directory table contains the physical address of the base of a page table, access rights, and memory management information.</li>
<li><strong>Sets of page tables</strong> — An entry in a page table contains the physical address of a page frame, access rights, and memory management information.</li>
</ul>
</blockquote>
<p>这里我画了一张表来进行说明</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="image-20201031171947780"></p>
<p>首先，这里出现的这个<strong>DirBase</strong>，实际上是CR3（一个控制寄存器），里面存放着<strong>页基址</strong>。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/notepad%E9%A1%B5%E5%9F%BA%E5%9D%80.png" alt="image-20201031145213470"></p>
<p>其实<strong>CR3</strong>的结构也是一张表，大小为4096字节，每个元素为4字节，所以有1024个元素。</p>
<p><strong>CR3</strong>里的<strong>页基址</strong>，指向一个<strong>PDT</strong>（Page Directory Table 页目录表），<strong>PDT</strong>的大小也是4096字节，能存放1024个元素。</p>
<p><strong>PDT</strong>里每个元素称为<strong>PDE</strong>（Page Directory Entry 页目录项），每个<strong>PDE</strong>又指向一个<strong>PTT</strong>（Page Translation Table 页翻译表）表，<strong>PTT</strong>的大小也是4096字节，能存放1024个元素。</p>
<p><strong>PTT</strong>里的元素叫<strong>PTE</strong>（page table entry 页表条目），通过<strong>PTE</strong>加上<strong>页内偏移</strong>也就是图中的偏移3，就可以来到<strong>线性地址</strong>对应的<strong>物理地址</strong>。</p>
<h1 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h1><p>系统在程序的逻辑地址空间的0x0位置，划分出一块64k的不可用空间，用来防止程序使用空指针，程序如果不意使用了空指针，再加上些结构元素偏移什么的，也鲜有超过 64K 的，所以就将这个区段空了出来，部分地址没有映射到物理内存，所以一访问就会出现page fault异常，操作系统捕捉到异常，根据访问的地址，就知道应用程序出现了空指针操作。</p>
<h2 id="访问0地址"><a href="#访问0地址" class="headerlink" title="访问0地址"></a>访问0地址</h2><h3 id="页内偏移为0的情况"><a href="#页内偏移为0的情况" class="headerlink" title="页内偏移为0的情况"></a>页内偏移为0的情况</h3><p>先来撸一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> * xxx = (<span class="keyword">int</span> *)<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,*xxx);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为读取的是0地址，运行肯定会报错</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/0%E5%9C%B0%E5%9D%80%E6%8A%A5%E9%94%99.png" alt="image-20201031232458065"></p>
<p>先来看看为什么会报错。p的地址为<code>0x13c5000</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/p%E5%9C%B0%E5%9D%80.png" alt="image-20201031232806936"></p>
<p>拆分</p>
<p><code>0000 0000 0100</code> = 0x4</p>
<p><code>0011 1100 0101</code> = 0x3c5</p>
<p>使用Windbg查看CR3</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/ZeroCR3.png" alt="image-20201101002111762"></p>
<p>通过偏移得到<strong>PDE</strong>地址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/ZeroPDE.png" alt="image-20201101002146165"></p>
<p>通过<strong>PDE</strong>加偏移得到<strong>PTE</strong>地址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/ZeroPTE.png" alt="image-20201101002236474"></p>
<p>这个地址下存放的就是变量p里的值 100</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/PTE100.png" alt="image-20201101002324857"></p>
<p>那么为什么0地址会访问不了呢？直接查看CR3不加偏移</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/CR300.png" alt="image-20201101002411955"></p>
<p>取0x00地址的值继续查看，可以看到PDE的0x00位置为空，也就是没用被挂上物理页</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/PTE00.png" alt="image-20201101002508227"></p>
<p>尝试将他挂上<code>0x57d3f867</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/0%E5%9C%B0%E5%9D%80%E6%8C%82%E7%89%A9%E7%90%86%E9%A1%B5.png" alt="image-20201101002706011"></p>
<p>继续运行程序，成功输出100</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E6%88%90%E5%8A%9F%E8%BE%93%E5%87%BA100.png" alt="image-20201101002838524"></p>
<h3 id="页内偏移不为0的情况"><a href="#页内偏移不为0的情况" class="headerlink" title="页内偏移不为0的情况"></a>页内偏移不为0的情况</h3><p>将全局变量移到main函数内，变成局部变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> * xxx = (<span class="keyword">int</span> *)<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,*xxx);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，这次的地址为<code>0x33fac8</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/0x33fac8.png" alt="image-20201101145711827"></p>
<p>ac8为页内偏移，把33f拆分一下</p>
<p><code>0000 0000 0000</code> =0</p>
<p><code>0011 0011 1111</code> =0x33f</p>
<p>使用WinDbg查看页基址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BBCR3.png" alt="image-20201101150101783"></p>
<p>跟着偏移走可以正常看见100</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB100.png" alt="image-20201101150513121"></p>
<p>将0x310b867写入0地址内，运行程序</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E5%86%99%E5%85%A50%E5%9C%B0%E5%9D%80.png" alt="image-20201101152506522"></p>
<p>可以看到，因为<code>*xxx</code>取值取的是0地址的0号偏移，读到了一个0</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E6%B2%A1%E6%9C%89%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB.png" alt="image-20201101152636838"></p>
<p>所以代码上取内容的时候要加上偏移</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> * xxx = (<span class="keyword">int</span> *)<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> offset = ((ULONG)&amp;p) &amp; <span class="number">0xFFF</span>; <span class="comment">//取后面12位的内容，也就是页内偏移</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,*(PULONG)((ULONG)xxx+offset)); <span class="comment">//因为直接+的话是指针+1，所以要先转为ULONG，再转回指针取值</span></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把代码放入0地址中执行"><a href="#把代码放入0地址中执行" class="headerlink" title="把代码放入0地址中执行"></a>把代码放入0地址中执行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;buf);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> code[]=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0xB8</span>,<span class="number">0x78</span>,<span class="number">0x56</span>,<span class="number">0x34</span>,<span class="number">0x12</span>,</span><br><span class="line">		<span class="number">0xff</span>,<span class="number">0xD0</span>,</span><br><span class="line">		<span class="number">0xC3</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">char</span> * p= (<span class="keyword">char</span> *)<span class="number">0</span>;</span><br><span class="line">	*(PULONG)&amp;code[<span class="number">9</span>] = (ULONG)MessageBoxA;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(p,code,<span class="keyword">sizeof</span>(code));</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__stdcall *FunctionProc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	HMODULE h = GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	FunctionProc func = (FunctionProc)GetProcAddress(h,<span class="string">&quot;asdjasd&quot;</span>);</span><br><span class="line">	func();</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/0%E5%9C%B0%E5%9D%80%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%95%88%E6%9E%9C.png" alt="image-20201101203558859"></p>
<p>上面的代码会导致缓冲区溢出，位避免缓冲区溢出，使用VirtualAlloc申请内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> * buf = (<span class="keyword">char</span>*) VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	*buf = <span class="number">1</span>; <span class="comment">//挂上物理页</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;buf);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> code[]=</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0x6a</span>,<span class="number">0x00</span>,</span><br><span class="line">		<span class="number">0xB8</span>,<span class="number">0x78</span>,<span class="number">0x56</span>,<span class="number">0x34</span>,<span class="number">0x12</span>,</span><br><span class="line">		<span class="number">0xff</span>,<span class="number">0xD0</span>,</span><br><span class="line">		<span class="number">0xC3</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">char</span> * p= (<span class="keyword">char</span> *)<span class="number">0</span>;</span><br><span class="line">	*(PULONG)&amp;code[<span class="number">9</span>] = (ULONG)MessageBoxA;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(p,code,<span class="keyword">sizeof</span>(code));</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__stdcall *FunctionProc)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	HMODULE h = GetModuleHandleA(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	FunctionProc func = (FunctionProc)GetProcAddress(h,<span class="string">&quot;asdjasd&quot;</span>);</span><br><span class="line">	func();</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="页的属性"><a href="#页的属性" class="headerlink" title="页的属性"></a>页的属性</h1><p>在拆分线性地址的时候，无论是PDE表还是PTE表里的元素，在使用的时候，都会把后三位忽略，因为这三位是<strong>页的属性</strong>，这一小节，将会详细介绍页的属性。</p>
<p>Intel白皮书中，有这样一张图详细介绍了PDE和PTE表的属性。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/PDE%E5%92%8CPTE%E7%9A%84%E6%9D%83%E9%99%90.png" alt="PDE和PTE的权限"></p>
<h2 id="P位（存在标志）"><a href="#P位（存在标志）" class="headerlink" title="P位（存在标志）"></a>P位（存在标志）</h2><p>该标志表明，该表项所指向的页或者页表当前是否在内存中。当置位该标志时，这个页在物理内存中，将执行地址转换。当该标志清零时，表示这个页不在内存中，如果处理器试图访问该页，将产生一个缺页异常(PF)。处理器并不置位或者清零该位;而是由操作系统来维护该标志的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> * buf = (<span class="keyword">char</span>*) VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	*buf = <span class="number">1</span>;</span><br><span class="line">	VirtualLock(buf,<span class="number">0x1000</span>);<span class="comment">//将页面锁定在物理内存中。这样页面将不会被交换到硬盘上，防止蓝屏</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;buf);</span><br><span class="line">    </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	*buf;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先确定地址没有错</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E7%A1%AE%E5%AE%9Ap%E6%B2%A1%E9%94%99.png" alt="image-20201102001756960"></p>
<p>将PDE的P位置为0</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E5%B0%86PDE%E7%9A%84P%E4%BD%8D%E7%BD%AE%E4%B8%BA00.png" alt="image-20201102002323998"></p>
<p>继续运行程序发现触发缺页异常，并蓝屏。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/p%E4%BD%8D%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8.png" alt="image-20201102002425233"></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/p%E4%BD%8D%E8%93%9D%E5%B1%8F.png" alt="image-20201102002645135"></p>
<h2 id="R-W位（读写标志位）"><a href="#R-W位（读写标志位）" class="headerlink" title="R/W位（读写标志位）"></a>R/W位（读写标志位）</h2><p>该标志确定对一个页或者一组页(比如，一个指向一个页表的页目录项)的读写权限。当这个标志为0时，该页是只读的;当这个标志为1时，该页是可读可写的。该标志与U/S标志和CRO寄存器中的WP标志共同起作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">char</span> *p =<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>,p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>char *p =&quot;123456&quot;;</code>这行代码是定义了一个所谓的字符串常量（其实是被分配到一块没有写权限的内存空间中），接下来测试修改PTE的R/W位来让他获得写权限。</p>
<p>首先先确定PTE表的地址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/RW%E4%BD%8DPTE%E8%A1%A8.png" alt="image-20201102155200764"></p>
<p>修改PTE表权限</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/RW%E4%BD%8DPTE%E6%9D%83%E9%99%90.png" alt="image-20201102155611218"></p>
<p>继续运行程序，成功修改</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E4%BF%AE%E6%94%B9RW%E6%9D%83%E9%99%90%E6%88%90%E5%8A%9F.png" alt="image-20201102155937005"></p>
<h2 id="U-S位-（User-Super）普通用户-超级用户-标志"><a href="#U-S位-（User-Super）普通用户-超级用户-标志" class="headerlink" title="U/S位 （User/Super）普通用户/超级用户 标志"></a>U/S位 （User/Super）普通用户/超级用户 标志</h2><p>该标志确定一个页或者一组页(比如，一个指向一个页表的页目录项)的用户权限。当这个标志被清零，该页的用户权限为超级用户的权限;该标志置位时，该页的用户权限为普通用户权限。这个标志与R/W标志和CRO寄存器中的WP标志共同起作用。</p>
<p>像R3不能访问R0地址就是这个位控制的。</p>
<p>随便拿GDT表的一个地址进行测试，这里我使用<code>0x80dd2ba0</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/us%E4%BD%8DGDT%E8%A1%A8.png" alt="image-20201102163612515"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">0x80dd2ba0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\r\n&quot;</span>,p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	*p = <span class="number">0x100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,*p);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先确定偏移正确</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/US%E4%BD%8D%E5%81%8F%E7%A7%BB%E6%AD%A3%E7%A1%AE.png" alt="image-20201102174810373"></p>
<p>修改权限</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E4%BF%AE%E6%94%B9us%E6%9D%83%E9%99%90.png" alt="image-20201102175212456"></p>
<p>继续运行程序，成功修改</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/us%E4%BD%8D%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F.png" alt="image-20201102175347884"></p>
<p>在windbg中也可以看见修改成功</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/uswindbg.png" alt="image-20201102175626105"></p>
<h2 id="A位（访问标志）"><a href="#A位（访问标志）" class="headerlink" title="A位（访问标志）"></a>A位（访问标志）</h2><p> 指明这个页或页表是否曾经被访问过。内存管理软件通常会在这个页或者页表被载入内存时，清零该位。当该页或者页表第一次被访问以后，处理器会置位该标志。<br>​ 这个标志是个“粘性”标志，就是说一旦被设置，处理器不会隐式的给它清零。只有软件能清零该位。内存管理软件使用访问位和脏位来调度页或者页表进出物理内存。</p>
<p> 在程序中申请的线性地址，在没有被访问过的情况下，是不会被挂上物理页的。当第一次被访问的时候，会出现一个<strong>页异常</strong>，然后对页进行修复（简单来说挂上物理页）。并把PDT和PTE的A位置1。</p>
<h2 id="D位（脏位）"><a href="#D位（脏位）" class="headerlink" title="D位（脏位）"></a>D位（脏位）</h2><p>指明该页是否曾经被写入过(在指向页表的页目录项（PDE）中，不使用该标志)。通常，内存管理软件在该页刚被载入内存时，将该标志清零。当该页的第一次写操作完成后，处理器置位该标志。这个标志是-一个粘性标志，就是说，一旦被设置，处理器不会隐式的对它清零。只有软件可以对它清零。内存管理软件使用访问位和脏位来调度页或者页表进出物理内存。</p>
<p>写入过一次一次后，该位被置1。</p>
<h2 id="PS标志-（页尺寸标志）"><a href="#PS标志-（页尺寸标志）" class="headerlink" title="PS标志 （页尺寸标志）"></a>PS标志 （页尺寸标志）</h2><p>如果PDE.ps = 0 代表是一个小页，也就是正常的101012分页，PDE后面还有PTE。</p>
<p>如果PDE.ps = 1 代表是一个大页，只有前10位有效，后面22位都是页内偏移。2^22=4194304，也就是大页有4M。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/PS%E4%BD%8D%E5%A4%A7%E9%A1%B5%E6%BC%94%E7%A4%BA.png" alt="image-20201103001341715"></p>
<h2 id="缓存位"><a href="#缓存位" class="headerlink" title="缓存位"></a>缓存位</h2><p>缓存位是由三个位组合进行生效的，一共会有8种情况，</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BB%84%E5%90%88.png" alt="image-20201107145755210"></p>
<p>这8种情况对应下图的几种效果</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/8%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%90%AB%E4%B9%89.png" alt="image-20201107150347871"></p>
<p>00（UC）：没有缓存（读写都直接操作内存条）</p>
<p>07 （UC-）：读的时候可能会读缓存，并不一定会读缓存</p>
<p>下面这种带W的，读的时候统统都是读缓存</p>
<p>01（WC）：有可能直写有可能回写</p>
<p>04 （WT）：同时写入缓存与内存中</p>
<p>05 （WP）：写保护，一写就触发异常</p>
<p>06 （WB）：先写到缓存，然后再等刷新机制刷新到内存中</p>
<p>这8种类型并不是固定的，是可以随意设置的。有一个PAT MSR的寄存器，编号为277。在Windbg中可以使用rdmsr+编号查看：</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/rdmsr277.png" alt="image-20201107161639697"></p>
<p>可以看到，一共是8个字节，也就是8种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 07 01 06 00 07 01 06</span><br></pre></td></tr></table></figure>
<p>当</p>
<p>PAT=0</p>
<p>PWT=0</p>
<p>PCD=0</p>
<p>需要查询第00个索引，也就是这里的<code>06</code></p>
<p>需要注意的是，PAT是需要设置的，默认是没有的。在不支持PAT的时候，只使用PCD和PWD这；两个标志组合成两位的0~3这四种组合</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E4%B8%8D%E6%94%AF%E6%8C%81PAT%E7%9A%84%E6%83%85%E5%86%B5.png" alt="image-20201107154049695"></p>
<h3 id="PAT位（页面属性表Page-Attribute-Table）"><a href="#PAT位（页面属性表Page-Attribute-Table）" class="headerlink" title="PAT位（页面属性表Page Attribute Table）"></a>PAT位（页面属性表Page Attribute Table）</h3><p>pat系统默认的是0，如果人为的置1的话，系统就会认为这个是无效的。</p>
<h3 id="PWT位-（Page-Write-Through）"><a href="#PWT位-（Page-Write-Through）" class="headerlink" title="PWT位 （Page Write Through）"></a>PWT位 （Page Write Through）</h3><p><code>PWT=1</code>：写<strong>Cache</strong>的时候也要将<strong>数据</strong>写入<strong>内存</strong>中<br><code>PWT=0</code>：写<strong>Cache</strong>的时候就只是写Cache，是否要映射到内存由<strong>CPU缓存控制器</strong>自己决定</p>
<p>1没有缓存，0可以有缓存</p>
<h3 id="PCD位-（Page-Cache-Disable）"><a href="#PCD位-（Page-Cache-Disable）" class="headerlink" title="PCD位 （Page Cache Disable）"></a>PCD位 （Page Cache Disable）</h3><p><code>PCD=1</code>：禁止某个页写入缓存（直接写入内存）<br><strong>比如</strong>：做页表用的页，已经存储在TLB中，可能就不需要再做缓存，而它的PCD一定为1</p>
<h2 id="G位-（全局页）"><a href="#G位-（全局页）" class="headerlink" title="G位 （全局页）"></a>G位 （全局页）</h2><p>当G位等于1，全局页进入TLB之后切换CR3（切换进程）TLB也不会被刷新（具体在<strong>TLB</strong>中的<strong>如何锁定缓存</strong>这一小节演示）。</p>
<h1 id="保护模式下操作系统是如何访问到物理内存的？"><a href="#保护模式下操作系统是如何访问到物理内存的？" class="headerlink" title="保护模式下操作系统是如何访问到物理内存的？"></a>保护模式下操作系统是如何访问到物理内存的？</h1><p>微软设计了构造了一个很巧妙的线性地址<code>C0300000</code>,用来查找自身的CR3，接下来就来介绍一下这个地址是怎么来的。</p>
<p>Windows的开机大致流程：</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/Windows%E7%9A%84%E5%BC%80%E6%9C%BA%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B.png" alt="image-20201103141348712"></p>
<p>刚开始进入系统的时候，并没有进程这个概念，因为是多任务的操作系统，有进程于线程的概念，系统也要用同样的方式来管理自己，就需要先把进程空间创建好。然后虚拟出一个进程。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/pid0.png" alt="image-20201103180028661"></p>
<p>但是，进程空间创建出来之后，操作系统只有虚拟地址，没有物理地址。要怎么管理呢？</p>
<p>首先，x86下一个进程空间为4G，一个页为4k。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最大虚拟地址&#x2F;页大小&#x3D;PTE个数</span><br><span class="line">PTE个数*指针大小&#x3D;管理这块虚拟地址所要用到的内存大小</span><br></pre></td></tr></table></figure>
<p>0x100000000/0x1000 = 0x100000</p>
<p>0x100000000的10进制为1,048,576</p>
<p>1,048,576/1024=1,024 也就是需要1024个pte来来管理内存</p>
<p>每个PTE为4字节，1024*4=4096，所以需要4096k也就是4M的内存来管理这4G的进程空间</p>
<p>在知道4G的进程空间中会分出4M来管理进程空间之后，我们假定这个规划出来的4M地址首地址为<code>0xC0000000</code>，注意！这个地址是可以随意变化的。</p>
<p>0xC0000000 / 4G *4M</p>
<p>0xC0000000 / 0x100000000 * 0x400000 = C * 0x40000 = 0x300000</p>
<p>0xC0000000+0x300000 = 0xC0300000</p>
<p>0xC0300000就是PDE的基址</p>
<p>现在就得到了两个范围</p>
<p><code>0xC0000000 - 0xC0300000</code> 都是PTE</p>
<p><code>0xC0300000 - 0xC0400000</code> 都是PDE</p>
<p>把C0000 000 拆分转一下二进制得到1100 也就是300*4</p>
<p>接下来去Windbg看一个神奇的东西，随便找一个进程，取页基址，这里我用system进程</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/systemCR3.png" alt="image-20201103182108006"></p>
<p>用基址加上300*4，又指回了自己，只是多个属性位了点东西</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/PDE%E5%8F%88%E6%8C%87%E5%90%91%E4%BA%86%E8%87%AA%E5%B7%B1.png" alt="image-20201103182255741"></p>
<p>也就是这样，这就是系统用来管理自己的CR3的算法，设计一个地址<code>C0300c00</code>回绕两次获取自身CR3，这就是<code>自映射</code>。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/PDE%E5%8F%88%E6%8C%87%E5%9B%9E%E4%BA%86PDE.png" alt="image-20201103200500668"></p>
<p><strong>其实世界上本没有PDE，当PTE多到需要专门管理了，PDE就有了。</strong></p>
<h2 id="程序获得自己的PDE与PET"><a href="#程序获得自己的PDE与PET" class="headerlink" title="程序获得自己的PDE与PET"></a>程序获得自己的PDE与PET</h2><p>当然，系统上运行的普通程序也可以使用这种方法来取得自己的PDE与PET。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,&amp;x);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，得到x的地址</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%BE%97%E8%87%AA%E5%B7%B1%E7%9A%84PDE%E4%B8%8EPET.png" alt="image-20201104134650563"></p>
<p>拆分<strong>25f</strong>得到</p>
<p><code>0000 0000 0000</code> = 0</p>
<p><code>0010 0101 1111</code> = 25f</p>
<p>先取得PDE与PTE，作对照</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1CR3.png" alt="image-20201104150102176"></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E5%AF%B9%E7%85%A7PDE%E4%B8%8EPTE.png" alt="image-20201104141444212"></p>
<p>PDE的基址为<code>C0300000</code>，根据公式<code>C0300000+i*4</code>可以得到第i个PDE</p>
<p>使用<code>C0300000</code>加上第一层偏移<code>0*4</code>结果还是<code>C0300000</code></p>
<p>接着再将<code>C0300</code>拆分</p>
<p><code>1100 0000 00</code> = C00</p>
<p><code>11 0000 0000</code> = C00</p>
<p>为了安全起见，使用<code>.process /i PID</code>让进程在执行的时候断下</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E8%BF%9B%E7%A8%8B%E6%96%AD%E7%82%B9.png" alt="image-20201104150020295"></p>
<p>通过C00得到PDE，可以看到是一样的</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E9%80%9A%E8%BF%87C30%E5%BE%97%E5%88%B0PDE.png" alt="image-20201104150418930"></p>
<p>接下来求PTE，PTE的基址为<code>C0000000</code>,根据公式<code>C0300000+i*4</code>可以得到第i个PTE</p>
<p>使用<code>C0000000</code>加上第二层偏移<code>0*4</code>结果是<code>C000025f</code>，然后对这个结果进行拆分</p>
<p><code>1100 0000 00</code> = C00</p>
<p><code>00 0000 0000</code> = 0</p>
<p>验证一下，成功得到自身PTE<code>0bfe4867</code></p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%ABPTE.png" alt="image-20201104151858580"></p>
<h2 id="系统是如何判断地址是否挂上物理页的"><a href="#系统是如何判断地址是否挂上物理页的" class="headerlink" title="系统是如何判断地址是否挂上物理页的"></a>系统是如何判断地址是否挂上物理页的</h2><p>在101012分页模式下，是由<strong>ntoskrnl.exe</strong>对分页进行管理的</p>
<p>路径<code>C:\Windows\System32\ntoskrnl.exe</code></p>
<p>把这个文件拖入IDA，搜索<code>MmIsAddressValid</code>函数，记得先设置好符号，否则是无法搜到的。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/MmIsAddressValid.png" alt="image-20201105150340874"></p>
<p>来到函数对应的反汇编处，可以看到把地址传给了<code>ECX</code>后又Call了一个<code>MiIsAddressValid</code>函数</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/MiIsAddressValid@8.png" alt="image-20201105151207521"></p>
<p>跟进去就是系统判断物理页的全部操作</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E7%B3%BB%E7%BB%9F%E5%88%A4%E6%96%AD%E7%89%A9%E7%90%86%E9%A1%B5.png" alt="image-20201105194848991"></p>
<p>(0x80000000 &gt;&gt; 12) = 80000 去掉后三位每位4字节3x4=12所以&gt;&gt;12</p>
<p>1000 0000 0000 0000 0000</p>
<p>3FF = 0011 1111 1111</p>
<p>&amp;3FF就是取后面10位</p>
<p>得到的内容要x4所以是&lt;&lt;2</p>
<p>FFC =1111 1111 1100</p>
<p>可以简化成（80000000 &gt;&gt;10）&amp; FFC</p>
<p>因为少右移两位所以&amp;取到的值要往前两位</p>
<p>PDE = （80000000&gt;&gt;20）&amp; ffc</p>
<p>根据上面逆向得到的内容，可以写出一份修改所有高地址US位的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pdeBase = <span class="number">0xC0300000</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pteBase = <span class="number">0xC0000000</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x80000000</span>;i&lt;=<span class="number">0xFFFFE000</span>;i+=<span class="number">0x1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> * pde = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(((i&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xFFC</span>)+pdeBase);</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> pdephy = *pde;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((pdephy &amp; <span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		pdephy |=<span class="number">0x7</span>;</span><br><span class="line">		*pde = pdephy;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((pdephy &amp; <span class="number">0x80</span>)==<span class="number">0x80</span>) <span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断PTE</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> * pte = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(((i&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0x3FFFFC</span>)+pteBase);</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> ptephy = *pte;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((ptephy &amp; <span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((pdephy &amp; <span class="number">0x80</span>)==<span class="number">0x80</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		ptephy |=<span class="number">0x7</span>;</span><br><span class="line">		*pte = ptephy;</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">callGate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//__asm</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	push ebp;</span></span><br><span class="line">	<span class="comment">//	mov ebp,esp;</span></span><br><span class="line">	<span class="comment">//	sub esp,0x100;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果要在这里写的话要保存现场</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//__asm</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	add esp,0x100;</span></span><br><span class="line">	<span class="comment">//	mov esp,ebp;</span></span><br><span class="line">	<span class="comment">//	pop ebp;</span></span><br><span class="line">	<span class="comment">//	retf;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		push fs;</span><br><span class="line">		mov ax,<span class="number">0x30</span>;</span><br><span class="line">		mov fs,ax;</span><br><span class="line">		call updateAddress;</span><br><span class="line">		pop fs;</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line">		mov eax,cr3;</span><br><span class="line">		mov cr3,eax;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,callGate);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> bufcode[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr bufcode</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> * x = (<span class="keyword">int</span> *)<span class="number">0x80b99010</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,*x);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="29912分页"><a href="#29912分页" class="headerlink" title="29912分页"></a>29912分页</h1><p>在使用32根地址总线的系统中，最大只支持4G的内存，使用101012分页没有任何问题。后来因为性能提升，地址总线扩展到了36根，也就是支持64G的内存。而101012分页的PDE和PTE的地址都是4个字节。已经不足以存放36根地址总线的地址。所以PDE和PTE就变成了占用8个字节。但是虚拟地址依然是4G。</p>
<p>在上一小节中介绍101012分页的时候有这样一张图说明了101012分页的寻址方式。</p>
<p>在101012分页中，PDT表和PTE表的大小都是4096字节。也就是最多只能存放1024个元素。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="image-20201031171947780"></p>
<p>与10-10-12不同，<strong>CR3不直接指向PDT表，而是指向一张新的表</strong>，叫做<strong>PDPT表（Page-Directory-Point-Table页目录指针表）</strong></p>
<p>PDPT表中的每一个成员叫做<strong>PDPTE（Page-Directory-Point-Table Entry，页目录指针表项）</strong>，每项占<strong>8个字节</strong></p>
<p>PDPT表<strong>只有4个成员</strong>，因为2位比特位只能满足2^2=4种情况</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/29912%E5%88%86%E9%A1%B5%E6%BC%94%E7%A4%BA.png" alt="image-20201106165257811"></p>
<p>首先最后的12位是属性位，不能动。</p>
<p>如果想增大物理内存的访问范围，就需要<strong>增大PTE</strong>，增大了多少呢？考虑对齐的因素，<strong>增加到8个字节</strong></p>
<p>由于PTE增大了，而PTT表的大小没变，依然是4KB，所以每张PTT表能放的<strong>PTE个数由原来的1024个减少到512个</strong>，512等于2的9次方，因此<strong>PTI=9</strong></p>
<p>由于2的9次方个PDE就能找到所有的PTT表，因此<strong>PDI=9</strong></p>
<p>分配到这里时，还剩下<strong>前2位未分配</strong>。于是就设计存放PDPTE表。</p>
<p>这就是29912的分页模式。</p>
<p>管理这块内存所需要的空间：<code>4*512*512*8=800000=8M</code></p>
<p>29912的PDE基址：<code>C0000000/100000000*800000+C0000000 = 800000*C = C0600000</code></p>
<h2 id="页的属性-1"><a href="#页的属性-1" class="headerlink" title="页的属性"></a>页的属性</h2><p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/29912%E9%A1%B5%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="image-20201106174456355"></p>
<p>后面<strong>12</strong>位的属性与<strong>101012</strong>分页的<strong>PDE</strong>与<strong>PTE</strong>的属性基本相同，需要注意的是最高位<strong>XD</strong>位。</p>
<p>在<strong>101012</strong>分页下，并没有管理执行的位，我们申请一块内存无论是可读还是可写，他都可以把数据当作代码来执行。</p>
<p>所以为了避免这个漏洞，在<strong>29912</strong>分页下，增加了<strong>DEP（数据执行保护）</strong>，就是这个<strong>XD</strong>位来进行管理的。</p>
<p>当<code>XD=1</code>时，这个页不能执行代码</p>
<p>当<code>XD=0</code>时，这个页可以执行代码</p>
<p>注意！PDE和PTE都有XD位，并且是与的关系，当一个为1一个为0时，还是可以执行，当两个都为1时才不可执行。</p>
<h2 id="大页"><a href="#大页" class="headerlink" title="大页"></a>大页</h2><p>在101012中的大页为4M是因为只用了前面10位，后面22位没用。</p>
<p>在29912中前面11位是有值的，后面的21位没用，所以大小为2^22=2M。</p>
<h2 id="29912的拆分"><a href="#29912的拆分" class="headerlink" title="29912的拆分"></a>29912的拆分</h2><p>如<code>80b99000</code></p>
<p>先去掉后12位剩余的转换为二进制</p>
<p>1000 0000 1011 1001 1001</p>
<p>从右往左取9位</p>
<p><code>1 1001 1001</code>= 199</p>
<p>第二部分</p>
<p><code>00 0000 101</code> = 5</p>
<p>最后两位</p>
<p><code>10</code> = 2</p>
<p>而且需要注意的是，寻址的时候要乘8，而且取值要取7位。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master/img/x86_kernel_page/%E5%8F%96%E5%80%BC36%E4%BD%8D.png" alt="image-20201107021131822"></p>
<h1 id="TLB-（Translation-Lookaside-Buffer）"><a href="#TLB-（Translation-Lookaside-Buffer）" class="headerlink" title="TLB （Translation Lookaside Buffer）"></a>TLB （Translation Lookaside Buffer）</h1><p>在当天普遍的分页模式下，CPU中的MMU模块要查询到物理地址，需要经过这几个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CR3-&gt;PDPT-&gt;PDE-&gt;PTE-&gt;物理地址</span><br></pre></td></tr></table></figure>
<p>MMU就是根据页表基地址寄存器从CR3一路查到PTE，最终找到物理地址(PTE页表中存储物理地址)。这样一级一级找下去，非常繁琐。每一次页表查找过程都需要进行内存访问。延时可想而知，非常影响性能。</p>
<p>为了解决这个问题，<strong>TLB</strong>就出现了。</p>
<p><strong>TLB</strong>里一共有4张表，两张小表，两张大表。</p>
<p>表中存放的线性地址为PTE或是PDE对应的偏移部分，属性则是用PDE与上PTE，统计是用来计算地址使用频率高低，需要向表中加入新元素时，会将使用频率低的地址移除。</p>
<p>小表的物理页帧存放的是4k的物理页帧。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master//blog_img/img/x86_kernel_page/image-20201109154028091.png" alt="img"></p>
<p>大表的物理存放的是2M(29912)的物理页帧。</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master//blog_img/img/x86_kernel_page/TLB%E5%A4%A7%E8%A1%A8%E5%9B%BE.png" alt="image-20201109154629542"></p>
<h2 id="什么是页帧？"><a href="#什么是页帧？" class="headerlink" title="什么是页帧？"></a>什么是页帧？</h2><p><strong>页帧</strong>全称<strong>物理页帧</strong>，就是PTE中存放的一个个物理页的首地址，或是PDE中存放的一个个物理大页的首地址。</p>
<h2 id="分页结构缓存"><a href="#分页结构缓存" class="headerlink" title="分页结构缓存"></a>分页结构缓存</h2><p><strong>分页结构缓存</strong>与<strong>TLB</strong>是互补的，MMU在查询一个物理地址的时候，首先会拿着线性地址去TLB中查找，如果找不到，就会拿着线性地址去分页结构缓存中查找。</p>
<p>在32位的分页模式下，只有PDE的缓存项会被建立，PTE是不会被缓存的。如果PDE指向的是一个物理页帧（大页），那么PDE的缓存项也不会建立。</p>
<p>因此，在32位分页模式下只有使用4k的页面才会建立PDE的缓存项。</p>
<h2 id="验证缓存的作用"><a href="#验证缓存的作用" class="headerlink" title="验证缓存的作用"></a>验证缓存的作用</h2><p>首先，取到p1的地址右移9位去除属性位（原本是右移动12位，但是后面要乘8相当于还要&lt;&lt;3所以直接右移9位即可）</p>
<p>把剩余的位与上0x7ffff8</p>
<p>and 0x7ffff8 右移9差三位，所以最后的8是把三位给抹了</p>
<p>29912去掉了12，还有20位，7ffff8正好取20位</p>
<p>29912页中每个元素是8个字节，所以需要 eax和eax+4一起组成了PDE eax+4是高4字节</p>
<p>所以他要取两次才是一个完整的</p>
<p>接下来就是访问一下0地址，然后保存结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line">PCHAR p1 = <span class="literal">NULL</span>;</span><br><span class="line">PCHAR p2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> temp2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad;</span><br><span class="line">		pushfd;</span><br><span class="line">		push fs;</span><br><span class="line">		mov ax,<span class="number">0x30</span>;</span><br><span class="line">		mov fs,ax;</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[p1];</span><br><span class="line">		shr eax,<span class="number">9</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0x7ffff8</span>;</span><br><span class="line">		add eax,<span class="number">0xc0000000</span>;</span><br><span class="line">		mov ecx,dword ptr ds:[eax];</span><br><span class="line">		mov ebx,dword ptr ds:[eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],ecx;</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000004</span>],ebx;</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>];</span><br><span class="line">		mov dword ptr ds:[temp1],eax;</span><br><span class="line"></span><br><span class="line">        mov eax,cr3;</span><br><span class="line">        mov cr3,eax</span><br><span class="line">        </span><br><span class="line">		mov eax,dword ptr ds:[p2];</span><br><span class="line">		shr eax,<span class="number">9</span>;</span><br><span class="line">		<span class="keyword">and</span> eax,<span class="number">0x7ffff8</span>;</span><br><span class="line">		add eax,<span class="number">0xc0000000</span>;</span><br><span class="line">		mov ecx,dword ptr ds:[eax];</span><br><span class="line">		mov ebx,dword ptr ds:[eax+<span class="number">4</span>];</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000000</span>],ecx;</span><br><span class="line">		mov dword ptr ds:[<span class="number">0xc0000004</span>],ebx;</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[<span class="number">0</span>];</span><br><span class="line">		mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">		pop fs;</span><br><span class="line">		popfd;</span><br><span class="line">		popad;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	p1 = (PCHAR)VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	p2 = (PCHAR)VirtualAlloc(<span class="literal">NULL</span>,<span class="number">0x1000</span>,MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	*(PULONG)p1 = <span class="number">0x1000</span>;</span><br><span class="line">	*(PULONG)p2 = <span class="number">0x2000</span>;</span><br><span class="line">	</span><br><span class="line">	temp1 = <span class="number">111</span>;</span><br><span class="line">	temp2 = <span class="number">222</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p1 = %x,p2 = %x,Func addr:%x\r\n&quot;</span>,p1,p2,test);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> bufcode[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr bufcode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;temp1:%x\r\n temp2:%x\r\n&quot;</span>,temp1,temp2);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在代码中</p>
<p>p1 = 0x1000;</p>
<p>p2 = 0x2000;</p>
<p>运行的情况下该p1p2的值是一样的，这就是因为MMU去查找了缓存</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master//img/x86_kernel_page/TEST_TLB.png" alt="image-20201110130906617"></p>
<h2 id="如何刷新缓存"><a href="#如何刷新缓存" class="headerlink" title="如何刷新缓存"></a>如何刷新缓存</h2><h3 id="方法1：操作CR3刷新缓存"><a href="#方法1：操作CR3刷新缓存" class="headerlink" title="方法1：操作CR3刷新缓存"></a>方法1：操作CR3刷新缓存</h3><p>这个操作是强制把所有TLB中的缓存移除，除了带G位的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">	pushad;</span><br><span class="line">	pushfd;</span><br><span class="line">	push fs;</span><br><span class="line">	mov ax,0x30;</span><br><span class="line">	mov fs,ax;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[p1];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp1],eax;</span><br><span class="line"></span><br><span class="line">       mov eax,cr3;</span><br><span class="line">       mov cr3,eax;</span><br><span class="line">       </span><br><span class="line">	mov eax,dword ptr ds:[p2];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">	pop fs;</span><br><span class="line">	popfd;</span><br><span class="line">	popad;</span><br><span class="line">	retf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后结果正确</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master//img/x86_kernel_page/%E6%93%8D%E4%BD%9CCR3%E5%88%B7%E6%96%B0%E7%BC%93%E5%AD%98.png" alt="image-20201110133542472"></p>
<h3 id="方法2：int3刷新缓存"><a href="#方法2：int3刷新缓存" class="headerlink" title="方法2：int3刷新缓存"></a>方法2：int3刷新缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">	pushad;</span><br><span class="line">	pushfd;</span><br><span class="line">	push fs;</span><br><span class="line">	mov ax,0x30;</span><br><span class="line">	mov fs,ax;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[p1];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp1],eax;</span><br><span class="line"></span><br><span class="line">       int 3;</span><br><span class="line">       </span><br><span class="line">	mov eax,dword ptr ds:[p2];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">	pop fs;</span><br><span class="line">	popfd;</span><br><span class="line">	popad;</span><br><span class="line">	retf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何锁定缓存"><a href="#如何锁定缓存" class="headerlink" title="如何锁定缓存"></a>如何锁定缓存</h2><h3 id="方法1：通过设置G位（全局页）锁定缓存"><a href="#方法1：通过设置G位（全局页）锁定缓存" class="headerlink" title="方法1：通过设置G位（全局页）锁定缓存"></a>方法1：通过设置G位（全局页）锁定缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">	pushad;</span><br><span class="line">	pushfd;</span><br><span class="line">	push fs;</span><br><span class="line">	mov ax,0x30;</span><br><span class="line">	mov fs,ax;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[p1];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	or ecx,0x100;G位是第9位，把第9位置1</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp1],eax;</span><br><span class="line">	</span><br><span class="line">       mov eax,cr3;尝试通过操作cr3刷新缓存</span><br><span class="line">       mov cr3,eax;</span><br><span class="line">       </span><br><span class="line">	mov eax,dword ptr ds:[p2];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">	pop fs;</span><br><span class="line">	popfd;</span><br><span class="line">	popad;</span><br><span class="line">	retf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行可以看到TLB依旧没有刷新</p>
<p><img src="https://gitee.com/ZDDR/blog_img/raw/master//img/x86_kernel_page/G%E4%BD%8DTLB%E6%B2%A1%E6%9C%89%E5%88%B7%E6%96%B0.png" alt="image-20201110134932715"></p>
<h2 id="如何强制刷新锁定的缓存"><a href="#如何强制刷新锁定的缓存" class="headerlink" title="如何强制刷新锁定的缓存"></a>如何强制刷新锁定的缓存</h2><h3 id="方法1：使用int3刷新全局页"><a href="#方法1：使用int3刷新全局页" class="headerlink" title="方法1：使用int3刷新全局页"></a>方法1：使用int3刷新全局页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">	pushad;</span><br><span class="line">	pushfd;</span><br><span class="line">	push fs;</span><br><span class="line">	mov ax,0x30;</span><br><span class="line">	mov fs,ax;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[p1];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	or ecx,0x100;G位是第9位，把第9位置1</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp1],eax;</span><br><span class="line">	</span><br><span class="line">       int 3;</span><br><span class="line">       </span><br><span class="line">	mov eax,dword ptr ds:[p2];</span><br><span class="line">	shr eax,9;</span><br><span class="line">	and eax,0x7ffff8;</span><br><span class="line">	add eax,0xc0000000;</span><br><span class="line">	mov ecx,dword ptr ds:[eax];</span><br><span class="line">	mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">	mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">	mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">	mov eax,dword ptr ds:[0];</span><br><span class="line">	mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">	pop fs;</span><br><span class="line">	popfd;</span><br><span class="line">	popad;</span><br><span class="line">	retf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2：使用invlpg指令将某地址从TLB中移除"><a href="#方法2：使用invlpg指令将某地址从TLB中移除" class="headerlink" title="方法2：使用invlpg指令将某地址从TLB中移除"></a>方法2：使用invlpg指令将某地址从TLB中移除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad;</span><br><span class="line">		pushfd;</span><br><span class="line">		push fs;</span><br><span class="line">		mov ax,0x30;</span><br><span class="line">		mov fs,ax;</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[p1];</span><br><span class="line">		shr eax,9;</span><br><span class="line">		and eax,0x7ffff8;</span><br><span class="line">		add eax,0xc0000000;</span><br><span class="line">		mov ecx,dword ptr ds:[eax];</span><br><span class="line">		mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">		mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">		mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">		or ecx,0x100;G位是第9位，把第9位置1</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[0];</span><br><span class="line">		mov dword ptr ds:[temp1],eax;</span><br><span class="line">        </span><br><span class="line">		mov eax,dword ptr ds:[p2];</span><br><span class="line">		shr eax,9;</span><br><span class="line">		and eax,0x7ffff8;</span><br><span class="line">		add eax,0xc0000000;</span><br><span class="line">		mov ecx,dword ptr ds:[eax];</span><br><span class="line">		mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">		mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">		mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">		invlpg dword ptr ds:[0];将0地址从TLB中移除</span><br><span class="line">		</span><br><span class="line">		mov eax,dword ptr ds:[0];</span><br><span class="line">		mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">		pop fs;</span><br><span class="line">		popfd;</span><br><span class="line">		popad;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法3：通过CR4的PGE位禁止全局页面生效"><a href="#方法3：通过CR4的PGE位禁止全局页面生效" class="headerlink" title="方法3：通过CR4的PGE位禁止全局页面生效"></a>方法3：通过CR4的PGE位禁止全局页面生效</h3><p>CR4中有一个PGE位（Page Global Enable 全局页面启用）</p>
<p>在G位中可以设置全局页，但是生不生效取决与CR4中的PGE位</p>
<p><code>PGE = 1</code> 全局页生效</p>
<p><code>PGE = 0</code> 全局页无效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad;</span><br><span class="line">		pushfd;</span><br><span class="line">		push fs;</span><br><span class="line">		mov ax,0x30;</span><br><span class="line">		mov fs,ax;</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[p1];</span><br><span class="line">		shr eax,9;</span><br><span class="line">		and eax,0x7ffff8;</span><br><span class="line">		add eax,0xc0000000;</span><br><span class="line">		mov ecx,dword ptr ds:[eax];</span><br><span class="line">		mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">		mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">		mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">		or ecx,0x100;G位是第9位，把第9位置1</span><br><span class="line"></span><br><span class="line">		mov eax,dword ptr ds:[0];</span><br><span class="line">		mov dword ptr ds:[temp1],eax;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;mov eax,cr4;</span><br><span class="line">        __emit 0x0f;</span><br><span class="line">        __emit 0x20;</span><br><span class="line">        __emit 0xe0;</span><br><span class="line">        </span><br><span class="line">        mov ebx,0x80;</span><br><span class="line">        not ebx;把0x80取反</span><br><span class="line">        and eax,ebx;把第8位置0</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;mov cr4,eax;</span><br><span class="line">        __emit 0x0f;</span><br><span class="line">        __emit 0x22;</span><br><span class="line">        __emit 0xe0;</span><br><span class="line">        </span><br><span class="line">		mov eax,dword ptr ds:[p2];</span><br><span class="line">		shr eax,9;</span><br><span class="line">		and eax,0x7ffff8;</span><br><span class="line">		add eax,0xc0000000;</span><br><span class="line">		mov ecx,dword ptr ds:[eax];</span><br><span class="line">		mov ebx,dword ptr ds:[eax+4];</span><br><span class="line">		mov dword ptr ds:[0xc0000000],ecx;</span><br><span class="line">		mov dword ptr ds:[0xc0000004],ebx;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		mov eax,dword ptr ds:[0];</span><br><span class="line">		mov dword ptr ds:[temp2],eax;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;mov eax,cr4;</span><br><span class="line">        __emit 0x0f;</span><br><span class="line">        __emit 0x20;</span><br><span class="line">        __emit 0xe0;</span><br><span class="line">        </span><br><span class="line">        mov ebx,0x80;</span><br><span class="line">		or eax,ebx;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;mov cr4,eax;</span><br><span class="line">        __emit 0x0f;</span><br><span class="line">        __emit 0x22;</span><br><span class="line">        __emit 0xe0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		pop fs;</span><br><span class="line">		popfd;</span><br><span class="line">		popad;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><blockquote>
<p>《牛逼的火哥》</p>
</blockquote>
<blockquote>
<p>《IA-32卷3：系统编程指南》(中文版)</p>
</blockquote>
<blockquote>
<p>《x86_x64体系探索及编程》(邓志)</p>
</blockquote>
<blockquote>
<p>《64-ia-32-architectures-software-developer-vol-3a-part-1-manual》</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42052102">以及 My classmates 大佬的博客</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ZDDR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zddr.net/2020/10/29/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E9%A1%B5/">https://zddr.net/2020/10/29/x86内核-保护模式--页/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zddr.net" target="_blank">ZDDR's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2020/02/11/1oFBM8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/10/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/"><img class="prev-cover" src="https://s2.ax1x.com/2020/02/11/1oFBM8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">x86内核-保护模式--控制寄存器</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/12/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E6%AE%B5/"><img class="next-cover" src="https://s2.ax1x.com/2020/02/11/1oFBM8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">x86内核-保护模式--段</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#101012%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">101012分页模式配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%A1%B5%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是分页模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text">寻找物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E5%81%8F%E7%A7%BB%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">三层偏移是什么东西？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0%E5%9C%B0%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">0地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE0%E5%9C%B0%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">访问0地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E4%B8%BA0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">页内偏移为0的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%86%85%E5%81%8F%E7%A7%BB%E4%B8%8D%E4%B8%BA0%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">页内偏移不为0的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%BB%A3%E7%A0%81%E6%94%BE%E5%85%A50%E5%9C%B0%E5%9D%80%E4%B8%AD%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">把代码放入0地址中执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">页的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#P%E4%BD%8D%EF%BC%88%E5%AD%98%E5%9C%A8%E6%A0%87%E5%BF%97%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">P位（存在标志）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R-W%E4%BD%8D%EF%BC%88%E8%AF%BB%E5%86%99%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">R&#x2F;W位（读写标志位）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#U-S%E4%BD%8D-%EF%BC%88User-Super%EF%BC%89%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7-%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7-%E6%A0%87%E5%BF%97"><span class="toc-number">3.3.</span> <span class="toc-text">U&#x2F;S位 （User&#x2F;Super）普通用户&#x2F;超级用户 标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A%E4%BD%8D%EF%BC%88%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">A位（访问标志）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D%E4%BD%8D%EF%BC%88%E8%84%8F%E4%BD%8D%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">D位（脏位）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PS%E6%A0%87%E5%BF%97-%EF%BC%88%E9%A1%B5%E5%B0%BA%E5%AF%B8%E6%A0%87%E5%BF%97%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">PS标志 （页尺寸标志）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D"><span class="toc-number">3.7.</span> <span class="toc-text">缓存位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PAT%E4%BD%8D%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%B1%9E%E6%80%A7%E8%A1%A8Page-Attribute-Table%EF%BC%89"><span class="toc-number">3.7.1.</span> <span class="toc-text">PAT位（页面属性表Page Attribute Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWT%E4%BD%8D-%EF%BC%88Page-Write-Through%EF%BC%89"><span class="toc-number">3.7.2.</span> <span class="toc-text">PWT位 （Page Write Through）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCD%E4%BD%8D-%EF%BC%88Page-Cache-Disable%EF%BC%89"><span class="toc-number">3.7.3.</span> <span class="toc-text">PCD位 （Page Cache Disable）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G%E4%BD%8D-%EF%BC%88%E5%85%A8%E5%B1%80%E9%A1%B5%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">G位 （全局页）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%88%B0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">保护模式下操作系统是如何访问到物理内存的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%BE%97%E8%87%AA%E5%B7%B1%E7%9A%84PDE%E4%B8%8EPET"><span class="toc-number">4.1.</span> <span class="toc-text">程序获得自己的PDE与PET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%B0%E5%9D%80%E6%98%AF%E5%90%A6%E6%8C%82%E4%B8%8A%E7%89%A9%E7%90%86%E9%A1%B5%E7%9A%84"><span class="toc-number">4.2.</span> <span class="toc-text">系统是如何判断地址是否挂上物理页的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29912%E5%88%86%E9%A1%B5"><span class="toc-number">5.</span> <span class="toc-text">29912分页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%B1%9E%E6%80%A7-1"><span class="toc-number">5.1.</span> <span class="toc-text">页的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E9%A1%B5"><span class="toc-number">5.2.</span> <span class="toc-text">大页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29912%E7%9A%84%E6%8B%86%E5%88%86"><span class="toc-number">5.3.</span> <span class="toc-text">29912的拆分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLB-%EF%BC%88Translation-Lookaside-Buffer%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">TLB （Translation Lookaside Buffer）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E5%B8%A7%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">什么是页帧？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%BB%93%E6%9E%84%E7%BC%93%E5%AD%98"><span class="toc-number">6.2.</span> <span class="toc-text">分页结构缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">验证缓存的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%B7%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.4.</span> <span class="toc-text">如何刷新缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E6%93%8D%E4%BD%9CCR3%E5%88%B7%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.4.1.</span> <span class="toc-text">方法1：操作CR3刷新缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9Aint3%E5%88%B7%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">6.4.2.</span> <span class="toc-text">方法2：int3刷新缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%94%81%E5%AE%9A%E7%BC%93%E5%AD%98"><span class="toc-number">6.5.</span> <span class="toc-text">如何锁定缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEG%E4%BD%8D%EF%BC%88%E5%85%A8%E5%B1%80%E9%A1%B5%EF%BC%89%E9%94%81%E5%AE%9A%E7%BC%93%E5%AD%98"><span class="toc-number">6.5.1.</span> <span class="toc-text">方法1：通过设置G位（全局页）锁定缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%E9%94%81%E5%AE%9A%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">6.6.</span> <span class="toc-text">如何强制刷新锁定的缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8int3%E5%88%B7%E6%96%B0%E5%85%A8%E5%B1%80%E9%A1%B5"><span class="toc-number">6.6.1.</span> <span class="toc-text">方法1：使用int3刷新全局页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8invlpg%E6%8C%87%E4%BB%A4%E5%B0%86%E6%9F%90%E5%9C%B0%E5%9D%80%E4%BB%8ETLB%E4%B8%AD%E7%A7%BB%E9%99%A4"><span class="toc-number">6.6.2.</span> <span class="toc-text">方法2：使用invlpg指令将某地址从TLB中移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E9%80%9A%E8%BF%87CR4%E7%9A%84PGE%E4%BD%8D%E7%A6%81%E6%AD%A2%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%95%88"><span class="toc-number">6.6.3.</span> <span class="toc-text">方法3：通过CR4的PGE位禁止全局页面生效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">7.</span> <span class="toc-text">References:</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.ax1x.com/2020/02/11/1oFBM8.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By ZDDR</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>