<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>x86内核-保护模式--段 | ZDDR's blog</title><meta name="keywords" content="ZDDR,逆向,内核,Pwn"><meta name="author" content="ZDDR"><meta name="copyright" content="ZDDR"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="双机调试环境配置虚拟机bcdedit添加调试启动拷贝当前启动项1bcdedit &#x2F;copy &amp;#123;current&amp;#125; &#x2F;d debug 如果拷贝成功可以获得新启动项ID  将启动项添加到当前启动顺序末尾1bcdedit &#x2F;displayorder &amp;#123;dd64745d-0a47-11eb-bc4d-cd0e0677722b&amp;#125; &#x2F;addlast 设置全局调试参数1.使">
<meta property="og:type" content="article">
<meta property="og:title" content="x86内核-保护模式--段">
<meta property="og:url" content="https://zddr.net/2020/10/12/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E6%AE%B5/index.html">
<meta property="og:site_name" content="ZDDR&#39;s blog">
<meta property="og:description" content="双机调试环境配置虚拟机bcdedit添加调试启动拷贝当前启动项1bcdedit &#x2F;copy &amp;#123;current&amp;#125; &#x2F;d debug 如果拷贝成功可以获得新启动项ID  将启动项添加到当前启动顺序末尾1bcdedit &#x2F;displayorder &amp;#123;dd64745d-0a47-11eb-bc4d-cd0e0677722b&amp;#125; &#x2F;addlast 设置全局调试参数1.使">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/11/1oFBM8.png">
<meta property="article:published_time" content="2020-10-11T16:00:00.000Z">
<meta property="article:modified_time" content="2020-11-17T16:00:00.000Z">
<meta property="article:author" content="ZDDR">
<meta property="article:tag" content="ZDDR,逆向,内核,Pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/02/11/1oFBM8.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zddr.net/2020/10/12/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E6%AE%B5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZDDR","link":"链接: ","source":"来源: ZDDR's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-18 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = '1'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/ZDDR/blog_img/raw/master/img/index_img/%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.ax1x.com/2020/02/11/1oFBM8.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZDDR's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">x86内核-保护模式--段</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-11T16:00:00.000Z" title="发表于 2020-10-12 00:00:00">2020-10-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-17T16:00:00.000Z" title="更新于 2020-11-18 00:00:00">2020-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/windows%E5%86%85%E6%A0%B8/">windows内核</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="双机调试环境配置"><a href="#双机调试环境配置" class="headerlink" title="双机调试环境配置"></a>双机调试环境配置</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="bcdedit添加调试启动"><a href="#bcdedit添加调试启动" class="headerlink" title="bcdedit添加调试启动"></a>bcdedit添加调试启动</h3><h4 id="拷贝当前启动项"><a href="#拷贝当前启动项" class="headerlink" title="拷贝当前启动项"></a>拷贝当前启动项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /copy &#123;current&#125; /d debug</span><br></pre></td></tr></table></figure>
<p>如果拷贝成功可以获得新启动项ID</p>
<p><img src="https://s1.ax1x.com/2020/10/10/0sVBQ0.png" alt="img"></p>
<h4 id="将启动项添加到当前启动顺序末尾"><a href="#将启动项添加到当前启动顺序末尾" class="headerlink" title="将启动项添加到当前启动顺序末尾"></a>将启动项添加到当前启动顺序末尾</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /displayorder &#123;dd64745d-0a47-11eb-bc4d-cd0e0677722b&#125; /addlast</span><br></pre></td></tr></table></figure>
<h4 id="设置全局调试参数"><a href="#设置全局调试参数" class="headerlink" title="设置全局调试参数"></a>设置全局调试参数</h4><p>1.使用串口COM 1进行通信,波特率为115200。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /dbgsettings SERIAL DEBUGPORT:1 BAUDRATE:115200</span><br></pre></td></tr></table></figure>
<p>2.物理双机1394串口调试，通道为23</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /dbgsettings 1394 CHANNEL:23</span><br></pre></td></tr></table></figure>
<p>3.使用USB端口进行双机调试，目标名称为DEBUGGING</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /dbgsettings USB TARGETNAME:DEBUGGING</span><br></pre></td></tr></table></figure>
<p>这里我们使用第一项即可。</p>
<h4 id="启用引导的调试"><a href="#启用引导的调试" class="headerlink" title="启用引导的调试"></a>启用引导的调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /bootdebug &#123;dd64745d-0a47-11eb-bc4d-cd0e0677722b&#125; ON</span><br></pre></td></tr></table></figure>
<h4 id="启用操作系统的调试"><a href="#启用操作系统的调试" class="headerlink" title="启用操作系统的调试"></a>启用操作系统的调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /debug &#123;dd64745d-0a47-11eb-bc4d-cd0e0677722b&#125; ON</span><br></pre></td></tr></table></figure>
<h4 id="设置等待时间为30秒"><a href="#设置等待时间为30秒" class="headerlink" title="设置等待时间为30秒"></a>设置等待时间为30秒</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /timeout 30</span><br></pre></td></tr></table></figure>
<h2 id="实体机"><a href="#实体机" class="headerlink" title="实体机"></a>实体机</h2><h2 id="WinDbg的配置"><a href="#WinDbg的配置" class="headerlink" title="WinDbg的配置"></a>WinDbg的配置</h2><p>在快捷方式 右键-&gt;属性 加入参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;G:\Windows Kits\10\Debuggers\x86\windbg.exe&quot;</span> -y srv*E:\WINDDK\symbols*http://msdl.microsoft.com/download/symbols;srv*E:\symbols*http://msdl.microsoft.com/download/symbols;E:\symbols -b -k com:port=//./pipe/com_1,baud=115200,pipe</span><br></pre></td></tr></table></figure>
<h2 id="WinDbg-Preview的配置"><a href="#WinDbg-Preview的配置" class="headerlink" title="WinDbg Preview的配置"></a>WinDbg Preview的配置</h2><p>将<strong>DbgX.Shell.exe</strong>发送到桌面快捷方式，同样在属性处添加参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files\WindowsApps\Microsoft.WinDbg_1.2007.6001.0_neutral__8wekyb3d8bbwe\DbgX.Shell.exe&quot;</span> -k com:port=//./pipe/com_1,baud=115200,pipe</span><br></pre></td></tr></table></figure>
<p>符号路径需要在软件内部的<strong>Settings</strong>进行配置，与上面WinDbg的相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srv*E:\WINDDK\symbols*http://msdl.microsoft.com/download/symbols;srv*E:\symbols*http://msdl.microsoft.com/download/symbols;E:\symbols</span><br></pre></td></tr></table></figure>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><h2 id="什么是保护模式？"><a href="#什么是保护模式？" class="headerlink" title="什么是保护模式？"></a>什么是保护模式？</h2><p>保护模式，是一种80286系列和之后的x86兼容CPU操作模式。</p>
<p>x86CPU的3个模式：实模式、保护模式、虚拟8086模式。<br>保护模式又分为：段保护模式、段页保护模式。</p>
<h1 id="段"><a href="#段" class="headerlink" title="段"></a>段</h1><h2 id="什么是段"><a href="#什么是段" class="headerlink" title="什么是段?"></a>什么是段?</h2><p>在了解什么是段之前，需要先了解一下CPU的发展历史</p>
<table>
<thead>
<tr>
<th>型号</th>
<th>位宽</th>
<th>总线位宽</th>
<th>地址位</th>
<th>寻址空间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>4004</td>
<td>4</td>
<td>4</td>
<td>单元格</td>
<td>640B</td>
<td>1971-11-15</td>
</tr>
<tr>
<td>8008</td>
<td>8</td>
<td>8</td>
<td>单元格</td>
<td>16K</td>
<td>s1972-4-1</td>
</tr>
<tr>
<td>8080</td>
<td>8</td>
<td>8</td>
<td>16</td>
<td>64K</td>
<td>1972-4-1</td>
</tr>
<tr>
<td>8086</td>
<td>16</td>
<td>16</td>
<td>20</td>
<td>1M</td>
<td>1978-6-8 X86起源</td>
</tr>
<tr>
<td>8088</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>外部总线最高是8位，其他参数与8086一致</td>
</tr>
<tr>
<td>80186</td>
<td>16</td>
<td>16</td>
<td>20</td>
<td>1M</td>
<td>简单认为比8086多了几条指令而已</td>
</tr>
<tr>
<td>80286</td>
<td>16</td>
<td>16</td>
<td>24</td>
<td>16M</td>
<td>多任务，多用户系统核心（半保护模式）</td>
</tr>
<tr>
<td>80386</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>4G</td>
<td>包含了分页的虚拟内存机制（保护模式）</td>
</tr>
<tr>
<td>80486</td>
<td>32</td>
<td>32</td>
<td>32</td>
<td>4G</td>
<td></td>
</tr>
</tbody></table>
<p>在Windows NT之前（80286之前），程序都是在实模式下运行，段是用来划分内存程序区域的，当一个程序想要调用另外一个程序，或是访问另一个程序的内存，只需要修改段的位置即可。</p>
<p><img src="https://s1.ax1x.com/2020/10/14/05lKaT.png" alt="img"></p>
<p>为了安全性，在Windows NT之后，就出现了虚拟内存的技术，每个程序都会得到一份独立的2GB虚拟线性地址和共享的2GB高地址，程序与程序直接不能直接访问内存，如果想要访问其他程序的内存，则需要通过内核的API进行操作。</p>
<p><img src="https://s1.ax1x.com/2020/10/14/05lMIU.png" alt="img"></p>
<p>那么这就会出现一个问题，既然高2G的内存是共享的，为什么进程在没有进<strong>内核态</strong>的时候无法访问高2G的内存地址呢？</p>
<p>这个就使用了<strong>页保护</strong>技术，将内存空间隔离。</p>
<p>那么问题又来了，既然有了页保护，那么还要段来做什么呢？有页不就够了吗？</p>
<p>段在保护模式下是一种权限，主要是用来限制R3的资源，如指令、寄存器。</p>
<p>在16位的时代（实模式），段的作用就是用来区分内存然后寻址，实模式下有四个段分别是CS SS DS ES。</p>
<p>到了保护模式，已经不需要用段来进行寻址了，inter为了向下兼容汇编，就把段用作权限划分。</p>
<p>在80386之后，段就由4个变成了6个，分别是CS SS DS ES FS GS。</p>
<ul>
<li><p>每个段分别表示的内容：</p>
<p>CS：代码段</p>
<p>DS：全部地址（数据）</p>
<p>SS：栈数据</p>
<p>ES：额外段（使用串指令时，如movsb、movsw等就会使用ES描述）</p>
<p>FS：额外段（在windows下，应用层保存的是<strong>TEB</strong>的地址，内核中保存的是<strong>KPCR</strong>）</p>
<p>GS：无论是Linux还是Windows，在x86下都没有使用</p>
</li>
</ul>
<h2 id="什么是TEB、PEB？什么是KPCR？"><a href="#什么是TEB、PEB？什么是KPCR？" class="headerlink" title="什么是TEB、PEB？什么是KPCR？"></a>什么是TEB、PEB？什么是KPCR？</h2><p>每一个线程，由两个结构来描述，内核描述的结构叫<strong>ETHREAD</strong>（执行体），而<strong>ETHREAD</strong>又包含了<strong>KTHREAD</strong>（微内核），在<strong>微内核</strong>里主要负责线程的调度以及各种内核环境相关的东西，<strong>执行体</strong>则负责保存R3下的一些数据，比如他属于哪一个进程，还有3环下应用程序块的一些对接。（这部分日后细说）。</p>
<p>而<strong>应用层</strong>描述的结构叫<strong>TEB</strong>(Thread Environment Block线程环境块)，主要作用是在R3下描述线程的属性，如当前上下文的环境是什么，寄存器里面保存的是什么，是否到R0了等等。</p>
<p>当从3环进入0环之后FS保存的就是<strong>KPCR</strong>（CPU的控制块），<strong>FS</strong>被<strong>KPCR</strong>占用后怎么获取当前线程呢？在0环中<strong>KPCR</strong>有一个当前线程的一个成员，直接调用即可获取当前线程。至于<strong>KPCR</strong>具体的作用，这个也是日后再说。</p>
<p>PEB则是进程环境块，日后再说日后再说。</p>
<h2 id="验证每个段的作用"><a href="#验证每个段的作用" class="headerlink" title="验证每个段的作用"></a>验证每个段的作用</h2><h3 id="ds"><a href="#ds" class="headerlink" title="ds"></a>ds</h3><p>当我们用汇编读写某一个地址时：<br>mov dword ptr ds:[0x123456],eax<br>其实内部是这样的ds.base+0x123456</p>
<p>在VS中编写一段内联汇编，这是标准的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">110</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, <span class="number">10</span>;</span><br><span class="line">        mov dword ptr ds:[value] , eax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段汇编的作用是把eax的值10赋值到value这个全局变量的地址中。</p>
<p>那么我把这里的ds删掉会怎么样呢？</p>
<p><img src="https://s1.ax1x.com/2020/10/14/05hwRO.png" alt="img"></p>
<p>也是可以正常运行的。</p>
<p><img src="https://s1.ax1x.com/2020/10/14/05hdJK.png" alt="img"></p>
<p>那么是不是不需要写段就可以正常运行呢？</p>
<p>其实并不是，我们只需要查看反汇编就可以看到，是编译器默认给我们加上了</p>
<p><img src="https://s1.ax1x.com/2020/10/14/054tXQ.png" alt="img"></p>
<p>用这种方法，就可以测试出每个段会在什么地方使用。</p>
<h3 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h3><p>接下来我们把value移到main内部，使其变成局部变量。</p>
<p><img src="https://s1.ax1x.com/2020/10/14/05xgTf.png" alt="img"></p>
<p>可以看到，编译器自动添加了SS段</p>
<p><img src="https://s1.ax1x.com/2020/10/14/05xee0.png" alt="img"></p>
<h3 id="cs"><a href="#cs" class="headerlink" title="cs"></a>cs</h3><p>测试修改CS段中的内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">110</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov ax, cs;</span><br><span class="line">        mov ds, ax;</span><br><span class="line">        mov ebx, <span class="number">0x100</span>;</span><br><span class="line">        mov dword ptr ds : [value] , ebx;</span><br><span class="line">        mov ax, es;</span><br><span class="line">        mov ds, ax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后直接报错</p>
<p><img src="https://s1.ax1x.com/2020/10/14/0IFkqJ.png" alt="img"></p>
<p>代码段只能读和执行。</p>
<h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>取<strong>TEB</strong>的地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="number">0x110</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, dword ptr fs : [<span class="number">0x18</span>] ;</span><br><span class="line">        mov dword ptr ds : [value] , eax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://s1.ax1x.com/2020/10/15/0TTsh9.png" alt="img"></p>
<p>怎么验证呢？</p>
<p>我们打开OD可以看到FS的值是一样的</p>
<p><img src="https://s1.ax1x.com/2020/10/15/0TT2X6.png" alt="img"></p>
<p>那么这个<code>0x18</code>又是什么东西呢？</p>
<p>其实就是TEB结构体的Self指针的偏移</p>
<p><img src="https://s1.ax1x.com/2020/10/15/0TTh7D.png" alt="img"></p>
<p>深入了解Windows内核和揭示超过60000种未公开的结构体☛[<a target="_blank" rel="noopener" href="https://www.vergiliusproject.com/">Vergilius]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在可以得出一个结论，段有权限，有基址，有限长。</span><br></pre></td></tr></table></figure>
<h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><h3 id="什么是段选择子？"><a href="#什么是段选择子？" class="headerlink" title="什么是段选择子？"></a>什么是段选择子？</h3><p>段选择符是一个16位的段标识符。它并不直接指向该段，而是指向定义该段的段描述符。</p>
<p>段选择子可以在VS<strong>调试窗口</strong>中的<strong>寄存器</strong>窗口查看</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HACUe.png" alt="img"></p>
<p>也可以在一些调试工具的寄存器窗口查看，如od：</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HATMt.png" alt="img"></p>
<p>或是在<strong>Windbg</strong>中使用<strong>r</strong>指令查看寄存器</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HmmtO.png" alt="img"></p>
<h3 id="一个长度仅16位的段选择子是如何包含这么多信息的？"><a href="#一个长度仅16位的段选择子是如何包含这么多信息的？" class="headerlink" title="一个长度仅16位的段选择子是如何包含这么多信息的？"></a>一个长度仅16位的段选择子是如何包含这么多信息的？</h3><p>Intel手册里给出了这样一张图，这张图描述的就是段选择子的含义：</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H6R0A.png" alt="img"></p>
<ul>
<li><p>0~1位为<strong>RPL</strong>（Requested Privilege Level）段请求权限</p>
<p><strong>RPL</strong>保存在选择子的最低两位。<strong>RPL</strong>说明的是进程对段访问的请求权限，意思是当前进程想要的请求权限。<strong>RPL</strong>的值由程序员自己来自由的设置。权限等级只有两位，意味着代表四种权限。</p>
<p>00：0环</p>
<p>01：1环</p>
<p>10：2环</p>
<p>11：3环</p>
</li>
<li><p>第2位为TI（Table Indicator）标记</p>
<p>当TI标记为0时，将去查询<strong>GDT</strong>表</p>
<p>当TI标记为1时，将去查询<strong>LDT</strong>表</p>
<p>由于windows使用的是单段模式，所以默认使用的是<strong>GDT</strong>表，所以在正常情况下<strong>TL</strong>都为0。</p>
</li>
<li><p>3~15位是一个索引</p>
<p>当确定需要查询的是GDT表或是LDT表后，就使用此索引来确定所需要的数据是在表中的哪一项。</p>
</li>
</ul>
<h3 id="拆分段选择子"><a href="#拆分段选择子" class="headerlink" title="拆分段选择子"></a>拆分段选择子</h3><p>这里使用<img src="https://s1.ax1x.com/2020/10/16/0Hnaa6.png" alt="img">作为例子</p>
<p>首先将30转换为16位二进制得到<img src="https://s1.ax1x.com/2020/10/16/0HuVJO.png" alt="img"></p>
<p>将后面的三位排除，这三位分别代表<strong>RPL</strong>和<strong>TI</strong></p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HuXnA.png" alt="img"></p>
<p>然后将剩下的Index按照4位补齐就变成了</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HK6Et.png" alt="img"></p>
<p>将0110转换为10进制得到6</p>
<p>所以需要在GDT表中查查找表的从0开始第6项</p>
<h2 id="GDT-Global-Descriptor-Table-全局描述符表"><a href="#GDT-Global-Descriptor-Table-全局描述符表" class="headerlink" title="GDT(Global Descriptor Table)全局描述符表"></a>GDT(Global Descriptor Table)全局描述符表</h2><p>GDT 的线性基地址在 GDTR （GDT寄存器）中，又因为每个描述符占 8 字节，因此，描述符在表内的偏移地址是索引号乘以 8。当处理器在执行任何改变段选择器的指令时（比如 pop、 mov、jmp far、 call far、 iret、 retf），就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。如果没有发现什么问题（比如超出了 GDT 的界限），就自动将找到的描述符加载到不可见的描述符高速缓存部分。 加载的部分包括段的线性基地址、段界限和段的访问属性。此后，每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。</p>
<h3 id="查看GDT寄存器"><a href="#查看GDT寄存器" class="headerlink" title="查看GDT寄存器"></a>查看GDT寄存器</h3><p><strong>GDT</strong>寄存器里保存着<strong>GDT</strong>表的基址，需要注意的是<strong>GDT</strong>寄存器并不是真实存在的寄存器，只是<strong>Intel</strong>和<strong>微软</strong>描述存在这个寄存器，并在<strong>Windbg</strong>设计的时候加入了<strong>gdtr</strong>这样一个查看<strong>gdt</strong>寄存器的命令，没有任何<strong>gdtr</strong>的指令。</p>
<p>在<strong>Windbg</strong>中使用<strong>gdtr</strong>查看<strong>GDT</strong>表的基址</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H1mqJ.png" alt="img"></p>
<h3 id="查看GDT表的长度"><a href="#查看GDT表的长度" class="headerlink" title="查看GDT表的长度"></a>查看GDT表的长度</h3><p>在<strong>Windbg</strong>中使用<strong>gdtl</strong>查看<strong>GDT</strong>表的长度</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H1xW6.png" alt="img"></p>
<p>可以看到，<strong>GDT</strong>表的长度为<strong>3ff</strong>，注意这里的<strong>3ff</strong>并不是说GDT表中存在<strong>3ff</strong>个项，而是说这张表有<strong>0x400</strong>个字节那么大。</p>
<p>这个<strong>0x400</strong>是可以根据<strong>Index</strong>的索引最大长度算出来的。</p>
<p><strong>Index</strong>的索引最大长度为<strong>13</strong>字节，<strong>2^13=8192</strong></p>
<p><strong>GDT</strong>表内每一项为<strong>8</strong>字节所以要除个<strong>8</strong></p>
<p><strong>8192/8=1024</strong></p>
<p><strong>1024</strong>的<strong>16</strong>进制就是<strong>0x400</strong></p>
<h3 id="查看GDT表的内容"><a href="#查看GDT表的内容" class="headerlink" title="查看GDT表的内容"></a>查看GDT表的内容</h3><p>在<strong>Windbg</strong>中使用<strong>d</strong>指令查看内存，默认查看方式为<strong>byte</strong>。</p>
<p><strong>GDT</strong>表中的每一项为<strong>8</strong>字节所以要使用<strong>qword</strong>方式查看，在<strong>windbg</strong>中写为<strong>dq</strong></p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HGFPI.png" alt="img"></p>
<p>这里继续用fs段的Index作为例子，在上文中fs段段选择子的Index是6</p>
<p>所以应该是这项</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H03WQ.png" alt="img"></p>
<p>还可以直接<code>dq 80b99000+6*8</code>这样显示的第一项就为对应Index的项了</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H02ex.png" alt="img"></p>
<p>如果我想知道<strong>Index</strong>的位置，每次都要拆开<strong>段选择子</strong>的内容？那岂不是很麻烦？</p>
<p>其实并不需要拆，只需要去掉二进制的后3位即可。</p>
<p>依旧使用<img src="https://s1.ax1x.com/2020/10/16/0Hnaa6.png" alt="img">作为例子</p>
<p>用<strong>0x30&amp;FF8</strong>得到结果<strong>0x30</strong></p>
<p>然后就在表中找到地址为<strong>30</strong>的项即可</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HBc9g.png" alt="img"></p>
<p>现在<strong>GDT</strong>表中对应的<strong>Index</strong>项已经找到了，那么问题又来了，通过<strong>Index</strong>找到的这八个字节是啥？</p>
<p>GDT表里的每一个项称为<strong>段描述符</strong>。</p>
<h3 id="在R3下获取GDT表"><a href="#在R3下获取GDT表" class="headerlink" title="在R3下获取GDT表"></a>在R3下获取GDT表</h3><p>在R3下可以使用sgdt（SAVE GDT）指令来读取GDT表的首地址到虚拟内存。</p>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>在上文中我们得知了GDT表里的每一个项称为<strong>段描述符</strong>。</p>
<p><strong>段描述符</strong>是GDT或LDT中的一个数据结构，它为处理器提供诸如段基址，段大小，访问权限及状态等信息。</p>
<p>在<strong>intel</strong>手册里<strong>段描述符</strong>这一章节有这样一个图，这张图描述的就是段描述符的含义：</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HyjzD.png" alt="img"></p>
<p>AVL-可供系统软件使用<br>BASE-段基地址<br>D / B-默认操作大小（0 = 16-位段； 1 = 32位段）<br>DPL-描述符特权级别<br>G-粒度<br>LIMIT-段限制<br>P-段存在<br>S-描述符类型（0 =系统； 1 =代码或数据）<br>TYPE-段类型</p>
<h3 id="拆解数据、代码段描述符"><a href="#拆解数据、代码段描述符" class="headerlink" title="拆解数据、代码段描述符"></a>拆解数据、代码段描述符</h3><p>这里使用<code>834093f2 fc003748</code>作为例子</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HhkHe.png" alt="img"></p>
<p>从后往前拆</p>
<p>Linit：0000 3748</p>
<p>Base：83f2fc00</p>
<p>Type：3</p>
<p>P,DPL,S这三个的值需要把9转换成二进制得到1001，然后填入标志内。</p>
<p>P：1</p>
<p>DPL：0</p>
<p>S：1</p>
<p>同理需要将4转换为二进制得到100，从左到右填入标志即可。</p>
<p>AVL：0</p>
<p>Def：0（21位默认是0）</p>
<p>D/B：0</p>
<p>G：1</p>
<h3 id="数据、代码段描述符中各个标志的含义"><a href="#数据、代码段描述符中各个标志的含义" class="headerlink" title="数据、代码段描述符中各个标志的含义"></a>数据、代码段描述符中各个标志的含义</h3><h4 id="P-（段存在）标志"><a href="#P-（段存在）标志" class="headerlink" title="P （段存在）标志"></a>P （段存在）标志</h4><p>P标志指出该段当前是否在内存中(1表示在内存中，0表示不在)。当指向该段描述符的段选择符装载人段寄存器时，如果这个标志为0,处理器会产生一个段不存在异常(NP)。</p>
<p>这里用一个小实验证明P标志的作用</p>
<p>首先使用<strong>WinDbg</strong>查看<strong>gdt</strong>表中未被使用的位置</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qXCKe.png" alt="img"></p>
<p>可以看到48这个位置为0，说明未被使用，这里就使用这个位置进行测试</p>
<p>编写内联汇编，这段汇编的意思是把ds段的值指向我们要用的48位置的表项，需要注意的是value需要用全局变量，不然编译器会自动替换成ss段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ULONG value = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ax,<span class="number">0x4B</span>;</span><br><span class="line">		mov ds,ax;</span><br><span class="line">		mov eax,dword ptr ds:[value];</span><br><span class="line">		mov ax,es;</span><br><span class="line">		mov ds,ax;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行发现崩溃，因为48处内存为0</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qXbz8.png" alt="img"></p>
<p>接下来在WinDbg上把一个数据段的表项拷贝去48位置</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qj779.png" alt="img"></p>
<p>再次查看GDT表的内存，可以看到，值已经成功写入48的位置</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qvPAA.png" alt="img"></p>
<p>再次运行程序，发现可以正常运行</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qvJjU.png" alt="img"></p>
<p>这时候尝试把P位改成0，0111是7，所以这里把f改成7</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qv041.png" alt="img"></p>
<p>dq检查修改成功</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qv2HH.png" alt="img"></p>
<p>再次运行程序，发现同样报错</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0qv5Ct.png" alt="img"></p>
<p>通过实验可以证明，P位如果为0，则整个段都无效。</p>
<h4 id="S（描述符类型）标志"><a href="#S（描述符类型）标志" class="headerlink" title="S（描述符类型）标志"></a>S（描述符类型）标志</h4><p>系统在解析段的时候，首先会解析P标志，确定段可用之后，再检测S标志。</p>
<p>当S为0时，段描述符将会解析为为代码，数据描述符。</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0HyjzD.png" alt="img"></p>
<p>当S为1时，段描述符将会被解析为系统描述符，关于系统描述符的部分请查看<a href="https://zddr.net/2020/10/12/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E6%AE%B5/#%E6%8B%86%E8%A7%A3%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E7%AC%A6">拆解系统描述符</a>。</p>
<h4 id="limit（段限长）标志"><a href="#limit（段限长）标志" class="headerlink" title="limit（段限长）标志"></a>limit（段限长）标志</h4><p>此标志保存了段最大的长度，与G标志配合使用。</p>
<h4 id="Base基地址域"><a href="#Base基地址域" class="headerlink" title="Base基地址域"></a>Base基地址域</h4><p>确定该段的第0字节在4GB线性地址空间中的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑地址（变量）+ Base &#x3D;线性地址</span><br></pre></td></tr></table></figure>
<p>这里用一个实验证明Base段是如何发挥作用的，这段内联汇编功能就是把value的值赋给value1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ULONG value = <span class="number">0x1000</span>;</span><br><span class="line">ULONG value1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value_adderss: %x\r\n&quot;</span>,&amp;value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value:%x\r\n&quot;</span>,value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value1:%x\r\n&quot;</span>,value1);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ax,<span class="number">0x4B</span>;</span><br><span class="line">		mov ds,ax;</span><br><span class="line">		mov ebx,dword ptr ds:[value];</span><br><span class="line">		mov ax,es;</span><br><span class="line">		mov ds,ax;</span><br><span class="line">		mov dword ptr ds:[value1],ebx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value1:%x\r\n&quot;</span>,value1);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先正常运行一遍</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0LtCh4.png" alt="img"></p>
<p>接下来把Base改成00000001</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0LNAPg.png" alt="img"></p>
<p>再次运行代码</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0LUzHP.png" alt="img"></p>
<p>可以看到<strong>value1</strong>的值变成了<strong>1000010</strong>，这是为啥呢？让我们来去<strong>value</strong>的内存<strong>12a7000</strong>看一看。</p>
<p>这是修改<strong>Base</strong>前输出的内容</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0Ld8JS.png" alt="img"></p>
<p>修改了Base后，取值的地址+1就变成了</p>
<p><img src="https://s1.ax1x.com/2020/10/17/0Ldho6.png" alt="img"></p>
<h4 id="G（粒度）标志"><a href="#G（粒度）标志" class="headerlink" title="G（粒度）标志"></a>G（粒度）标志</h4><p>G标志确定段限长扩展的增量。当G标志为0，段限长以字节为单位; G标志为1，段限长以4KB为单位。</p>
<p>G=1 limit是按照页为单位的，一个页的大小为0x1000，4096字节。（一般用来描述代码段）</p>
<p>因为是从0开始所以要先加1</p>
<p>如 (000fffff+1)*0x1000 - 1字节</p>
<p>或000fffff * 0x1000 +0xFFF</p>
<p>G=0 limit是按照字节为单位的（一般用来描述数据段）</p>
<p>如FFF=0x1000=4096字节 刚好等于一个页的大小，超出就不可以访问了。</p>
<h4 id="TYPE域"><a href="#TYPE域" class="headerlink" title="TYPE域"></a>TYPE域</h4><p>当段描述符中的S标志(描述符类型)为1时，该描述符为代码段描述符或者数据段描述符。</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H79gA.png" alt="img"></p>
<p>表中已经很人性化的把数据段和代码段分隔开来了，只要值Type的值小于8，那么就是数据段，反之大于8就是代码段。</p>
<p>数据段：</p>
<p>E (Expand)：limit的方向，规定段是向上扩展还是向下扩展</p>
<p>W (Write)：是否可写</p>
<p>A (Accessed)：当这个段被使用过一次之后，A就会被置为1。</p>
<p>如果E 位是用来确定栈是向上拓展的话，Base到Limit的范围是可以访问的。</p>
<p>如果E 位是用来确定栈是向下拓展的话，Base到Limit的范围是不可以访问的。除了Base到Limit的范围其他的才是可以访问的范围。</p>
<p>代码段：</p>
<p>C (Conforming)：一致位，用于区分<strong>一致代码段</strong>和<strong>非一致代码段</strong>，<strong>非一致代码段</strong>就是我们现在所用的代码，R3只能访问R3，R0只能访问R0，比如在应用层不可以直接调用内核函数，而一致代码段在R3下可以直接调用R0的函数，但是R0不可以降权调用R3的函数。</p>
<p>R (Read): 是否可读</p>
<p>A (Accessed)：当这个段被使用过一次之后，A就会被置为1。</p>
<p>以上面的<code>Tpye：3</code>作为例子</p>
<p>将3转换为二进制得到<code>0011</code></p>
<p>类型域的最高位(段描述符的第二个双字的第11位)将决定该描述符为数据段描述符(为0)或者代码段描述符(为1)。</p>
<p>也就是0011中的第一个0表示了这个段描述符描述的是一个数据段。</p>
<p><img src="https://s1.ax1x.com/2020/10/16/0H7bGQ.png" alt="img"></p>
<h4 id="D-B标志"><a href="#D-B标志" class="headerlink" title="D/B标志"></a>D/B标志</h4><h5 id="D"><a href="#D" class="headerlink" title="D"></a>D</h5><p>D：描述代码段的作用，如果为1则按照默认操作数是32位，如果为0则是16位。</p>
<p>注意cs段是无法直接修改的，如<code>mov cs,ax</code></p>
<p>要修改cs的话要间接修改，也就是使用跨段跳转 格式为<code>JMP 去哪个段:地址</code>如<code>jmp 0x4b:0x12345678</code></p>
<p>测试cs段的DB位的作用：</p>
<p>首先 同样把GDT表中48位置的内容修改，这里DB位为1</p>
<p><img src="https://s1.ax1x.com/2020/10/18/0jinGF.png" alt="img"></p>
<p>到OD中测试，修改断点处汇编为<code>jmp 0x4b:0x11d1f2e</code>，如果正常执行的话将会跳转到<strong>0x11d1f2e</strong>的位置执行<code>push 0x14</code></p>
<p><img src="https://s1.ax1x.com/2020/10/18/0jiJIK.png" alt="img"></p>
<p>执行后可以看到CS已经被修改成了0x4B</p>
<p><img src="https://s1.ax1x.com/2020/10/18/0j7Man.png" alt="img"></p>
<p>现在继续执行这行push指令，发现一切正常，14被压入栈内9C减4的位置</p>
<p><img src="https://s1.ax1x.com/2020/10/18/0j74it.png" alt="img"></p>
<p>接下来测试把D/B位改为0</p>
<p><img src="https://s1.ax1x.com/2020/10/18/0j7zWV.png" alt="img"></p>
<p>再次测试，请注意 执行push前栈地址为<code>0x056F88C</code>，正常情况下把0x14压栈是放在8C-4也就是88的位置</p>
<p><img src="https://s1.ax1x.com/2020/10/18/0jbQ3V.png" alt="img"></p>
<p>执行push，发现0x14以16字节的方式压入了8A的位置，而且栈全乱了</p>
<p><img src="https://s1.ax1x.com/2020/10/19/0jOu4A.png" alt="img"></p>
<h5 id="B"><a href="#B" class="headerlink" title="B"></a>B</h5><blockquote>
<p>堆栈段(由SS寄存器所指向的数据段)这 个标志被称为B (big) 标志，它为隐含的栈操作(如push, pop和call) 确定栈指针值的位位数。如果该&gt;标志为1，则使用的是32位的栈指针，该指针放在32位的ESP寄存器中;若该标志为0，则使用的是放在16位SP寄存器中的16位的栈指针。如果该堆栈段为一个向下扩展的数据段，B标志还确定了该堆栈段的地址上界。—— IA-32 Intel 架构软件开发人员手册</p>
</blockquote>
<p>从intel官方文档的描述中可以得知，B位有两个作用，第一个是对SS寄存器所指向的数据段（一般为栈）的操作的指针位数有影响，另一个是确定栈为向上还是向下扩展。</p>
<p>在这里我测试了两种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS DB &#x3D; 1 SS DB&#x3D;0</span><br><span class="line">CS DB &#x3D; 0 SS DB&#x3D;0</span><br></pre></td></tr></table></figure>
<p>这两种情况都会触发异常，所以无法查看效果。</p>
<h4 id="DPL（Descriptor-Privilege-Level）描述符特权级"><a href="#DPL（Descriptor-Privilege-Level）描述符特权级" class="headerlink" title="DPL（Descriptor Privilege Level）描述符特权级"></a><strong>DPL</strong>（Descriptor Privilege Level）描述符特权级</h4><p>要说<strong>DPL</strong>的话,就不得不先来说说<strong>RPL</strong>和<strong>CPL</strong>。</p>
<p><strong>Intel</strong>设置<strong>DPL</strong>、<strong>RPL</strong>、<strong>CPL</strong>以实现段的分级和权限检查。</p>
<p><strong>RPL</strong>: Requested Privilege Level, 请求特权级<br><strong>CPL</strong>: Current Privilege Level，当前特权级<br><strong>DPL</strong>: Descriptor Privilege Level，描述符特权级</p>
<p><strong>RPL</strong>存在于段选择子(Segment Selector)中，<strong>CPL</strong>存在于段寄存器中，如(<code>CS, SS, DS</code>)<br><strong>RPL</strong>和<strong>CPL</strong>都占用2个bit, 取值范围0~3, 值越小，特权级越高。</p>
<p>作为段选择子的时候，<strong>cs</strong>和<strong>ss</strong>比较特殊，它们的<strong>RPL</strong>代表着当前进程的特权级，因此，二者的<strong>RPL</strong>又叫<strong>CPL</strong>。</p>
<p>是不是有点绕，没关系，可以通过实验来理解一下。</p>
<h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5><p>测试数据段权限：</p>
<p>在Windbg中把<strong>0x48</strong>的位置设置<strong>DPL</strong>为3</p>
<p><img src="https://s1.ax1x.com/2020/10/20/BpMUKA.png" alt="img"></p>
<p>OD设置<strong>ds</strong>段选择子为<strong>0x4B</strong>，也就是<strong>RPL</strong>=3，<strong>CPL</strong>=3并使用<strong>ds</strong>进行一下内存操作，给栈里赋个100。</p>
<p>三行指令执行完毕，一切正常。</p>
<p><img src="https://s1.ax1x.com/2020/10/20/BpQwQJ.png" alt="img"></p>
<p>接下来在Windbg中把<strong>0x48</strong>的位置设置<strong>DPL</strong>为0</p>
<p><img src="https://s1.ax1x.com/2020/10/20/BpQvOs.png" alt="img"></p>
<p>再次测试，发现直接触发异常，并且DS的值被还原成了23（至于为什么会还原成23，日后再说）</p>
<p><img src="https://s1.ax1x.com/2020/10/20/Bp1FEt.png" alt="img"></p>
<p>接下来测试RPL小于DPL的情况</p>
<p>先把DPL改成3，再把0x4B改成0x48进行测试</p>
<p><img src="https://s1.ax1x.com/2020/10/20/BpfsF1.png" alt="img"></p>
<p><strong>总结</strong>：</p>
<p>普通数据段的权限检查规则</p>
<p><code>CPL &lt;= DPL &amp;&amp; RPL &lt;= DPL</code> 注意这里的小于是指权限，不是数值。</p>
<p>数据段CPL和RPL的权限大于或者等于DPL，可以切换，反之不能。</p>
<h5 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h5><p>使用Windbg将48处修改为代码段</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B92MBd.png" alt="img"></p>
<p>内联汇编实现修改CS段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4B</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	*(<span class="keyword">int</span> *)&amp;buf[<span class="number">0</span>]=(<span class="keyword">int</span>)test;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr ss:[buf];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试可以正常运行</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9fe3V.png" alt="img"></p>
<p>但是这样会导致堆栈不平衡</p>
<p>我们都知道，在调用函数的时候会将返回地址压入栈中，因为在执行CALL FWORD的时候，不单单压入了返回地址，还压入了被修改之前的段选择子</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B95XqS.png" alt="img"></p>
<p>所以<strong>ret</strong>的时候要使用<strong>retf</strong>，让它返回6个字节堆栈才能平衡。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4B</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	*(<span class="keyword">int</span> *)&amp;buf[<span class="number">0</span>]=(<span class="keyword">int</span>)test;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr ss:[buf];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用jmp，但是要自己进行堆栈平衡</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4B</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	*(<span class="keyword">int</span> *)&amp;buf[<span class="number">0</span>]=(<span class="keyword">int</span>)test;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">        push <span class="number">0x1b</span>;</span><br><span class="line">        lea eax,[haha];</span><br><span class="line">        push eax;</span><br><span class="line">		jmp fword ptr ss:[buf];</span><br><span class="line">haha:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在测试把0x4B改成0x48运行，可以正常运行，查看寄存器发现，系统又帮我们改回了0x4B，因为判断权限的时候会用RPL去与DPL。</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9TMDK.png" alt="img"></p>
<p>接下来将 f 改成 9</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B97gFe.png" alt="img"></p>
<p>测试运行 触发异常</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B97xO0.png" alt="img"></p>
<p>测试将0x48改为0x4B，依旧触发异常</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9Hr1s.png" alt="img"></p>
<p>然后，手动将栈内保存的1B改为18，测试retf的权限，发现依旧异常</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9xPzD.png" alt="img"></p>
<p><strong>总结</strong>：</p>
<p>代码段的权限检查规则</p>
<p>必须要<code>CPL=DPL</code></p>
<p>RPL在提权的时候没有用，在降权的时候才有用，因为判断权限的时候会用RPL去与DPL。</p>
<p>CALL JMP 权限往高或者同等级下 可切换cs。</p>
<p>retf iretd 权限同等或者低于当前权限 可切cs。</p>
<h3 id="拆解系统描述符"><a href="#拆解系统描述符" class="headerlink" title="拆解系统描述符"></a>拆解系统描述符</h3><p>在<strong>段描述符</strong>这一章节的前半部分，说的都是数据、代码段描述符，也就是S位等于0的情况，当S位为1时描述符就是<strong>系统描述符</strong>。</p>
<p>系统描述符又可以分为两类：<strong>系统段描述符</strong>和<strong>门描述符</strong>。<strong>系统段描述符</strong>指向系统段（<strong>LDT</strong>和<strong>TSS</strong>段）。<strong>门描述符</strong>它们自身就是“门“，它们或者持有指向在代码段的过程的入口点的指针，或者持有TSS (任务门)的段选择符。表<strong>3-2</strong>显示了对系统段描述符和门]描述的类型域的译码。</p>
<p><img src="https://s1.ax1x.com/2020/10/22/BFfI2R.png" alt="img"></p>
<h4 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h4><p>为了能够访问不同特权级的代码段，处理器提供了一 个特殊的描述符集合，叫做<strong>门描述符</strong>。</p>
<h5 id="调用门（Call-Gate）"><a href="#调用门（Call-Gate）" class="headerlink" title="调用门（Call Gate）"></a>调用门（Call Gate）</h5><p>调用门为不同特权级间的进程控制转换提供了便利。它们一般只用在操作系统中或者使用特权级保护机制的程序里。</p>
<p><img src="https://s1.ax1x.com/2020/10/23/Bkznij.png" alt="img"></p>
<p>Offset in Segment：段中的偏移</p>
<p>Segment Selector：段选择子</p>
<ul>
<li>准备一个进入0环的函数</li>
<li>获取这个函数的地址</li>
<li>最好关闭地址随机化（ASLR），不然运行一次要改一次调用门的偏移</li>
<li>在test函数内必须使用int 3，因为IDE的断点是R3的断点，进入R0就会失效。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;test func addr:%x\r\n&quot;</span>,test);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">xor</span> eax,eax;</span><br><span class="line">		call fword ptr buf;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先运行程序得到test函数的地址</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAJwa8.png" alt="img"></p>
<p>构造调用门</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40EC00 00081000</span><br></pre></td></tr></table></figure>
<p>Offset in Segment 15:00：40EC00 0008<code>1000</code></p>
<p>Segment Selector：40EC00 <code>0008</code>1000</p>
<p>Param.Count：40EC0<code>0</code> 00081000</p>
<p>567位默认为0：40EC<code>0</code>0 00081000</p>
<p>Type（1110）：40E<code>C</code>00 00081000</p>
<p>P，DPL，0（1110）：40<code>E</code>C00 00081000</p>
<p>Offset in Segment 31:16：<code>40</code>EC00 00081000</p>
<p>将构造门写入gdt表</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAUke1.png" alt="img"></p>
<p>执行代码，test函数的int 3成功断下</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAU3wt.png" alt="img"></p>
<p>并且CS变成了8</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAdyzF.png" alt="img"></p>
<p>接下来调用R0输出函数<strong>DbgPrint</strong>验证是否提权成功</p>
<p>在WinDbg查看<strong>DbgPrint</strong>的地址</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BA0su4.png" alt="img"></p>
<p>得到首地址<code>83e4f41f</code>,构造一个函数指针。</p>
<ul>
<li>注意！必须要保存环境并把fs设置为0x30（KPCR），否则蓝屏</li>
<li>由于__cdecl是外平栈，所以我们要自己手动add esp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call_Gate.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__cdecl *DbgPrintProc)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Format, ...)</span></span>;</span><br><span class="line">DbgPrintProc DbgPrint = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> * TestStr = <span class="string">&quot;R0 HELLO&quot;</span>;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		push fs;</span><br><span class="line"></span><br><span class="line">		mov ax,<span class="number">0x30</span>;</span><br><span class="line">		mov fs,ax;</span><br><span class="line"></span><br><span class="line">		mov eax,[TestStr];</span><br><span class="line">		push eax;</span><br><span class="line">		call DbgPrint;</span><br><span class="line">		add esp,<span class="number">0x4</span>;</span><br><span class="line"></span><br><span class="line">		pop fs;</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint = (DbgPrintProc)<span class="number">0x83e4f41f</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;test func addr:%x\r\n&quot;</span>,test);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">xor</span> eax,eax;</span><br><span class="line">		call fword ptr buf;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序后WinDbg成功输出字符串</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BArj8x.png" alt="img"></p>
<p>测试读取gdt表内容</p>
<ul>
<li>取esp+2的位置是因为 sgdt去到的不单止是gdt表的地址还有他的限长03ff</li>
<li>写value = 100;的原因是因为如果只有一个定义，编译器会认为你没有使用他，只会给他一个线性地址，不会挂上物理页，就会导致缺页蓝屏。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(__cdecl *DbgPrintProc)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * _Format, ...)</span></span>;</span><br><span class="line">DbgPrintProc DbgPrint = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> * TestStr = <span class="string">&quot;R0 HELLO&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//int 3;</span></span><br><span class="line">		pushfd;</span><br><span class="line">		pushad;</span><br><span class="line">		push fs;</span><br><span class="line"></span><br><span class="line">		mov ax,<span class="number">0x30</span>;</span><br><span class="line">		mov fs,ax;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		sub esp,<span class="number">8</span>;</span><br><span class="line">		mov eax,esp;</span><br><span class="line">		sgdt [eax];</span><br><span class="line">		mov eax,[esp+<span class="number">2</span>];</span><br><span class="line">		mov eax,[eax+<span class="number">8</span>];</span><br><span class="line">		mov value,eax;</span><br><span class="line"></span><br><span class="line">		add esp,<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">		pop fs;</span><br><span class="line">		popad;</span><br><span class="line">		popfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		retf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint = (DbgPrintProc)<span class="number">0x83e4f41f</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;test func addr:%x\r\n&quot;</span>,test);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	value = <span class="number">100</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">xor</span> eax,eax;</span><br><span class="line">		call fword ptr buf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x\r\n&quot;</span>,value);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功读取</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BA2pEF.png" alt="img"></p>
<p>如果需要带参的话在段选择子里的Param.Count加上参数的数量<code>40EC01 00081000</code>，然后call之前把参数压栈。</p>
<p>因为加上参数之后是入栈了5个参数所以要retf 0x4，不然会栈不平衡，导致蓝屏。而且retf不单止会平衡R0的栈，还会把R3的栈平衡。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		retf <span class="number">0x4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x4b</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push <span class="number">0x12345678</span>;</span><br><span class="line">		call fword ptr buf;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行在断点断下的时候查看R0的esp发现这个值是被放到了中间</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAbfit.png" alt="img"></p>
<p>这时我们再查看R3下的栈12fe4c，发现这里也保存了一份</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BALkng.png" alt="img"></p>
<p>其实我们push是push到R3的esp，然后cpu根据Param.Count的值无脑复制过去的。</p>
<ul>
<li>要使用调用门提权的话 必须要CPL==DPL</li>
</ul>
<h5 id="中断门（Interrupt-Gate）"><a href="#中断门（Interrupt-Gate）" class="headerlink" title="中断门（Interrupt Gate）"></a>中断门（Interrupt Gate）</h5><h6 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h6><p>中断是一种机制，用来处理硬件需要向CPU输入信息的情况。 比如鼠标，键盘等。</p>
<p>中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<p>硬件 -&gt;中断</p>
<p>软件-&gt;模拟中断-&gt;异常</p>
<h6 id="IDT表（Interrupt-Descriptor-Table）中断描述符表"><a href="#IDT表（Interrupt-Descriptor-Table）中断描述符表" class="headerlink" title="IDT表（Interrupt Descriptor Table）中断描述符表"></a>IDT表（Interrupt Descriptor Table）中断描述符表</h6><ul>
<li>r ldtr 查看IDT表基址</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/26/Bnx6BR.png" alt="img"></p>
<ul>
<li>r ldtl 查看IDT表长度</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/26/Bnx7DA.png" alt="img"></p>
<ul>
<li>查看IDT表</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/26/BuSpRO.png" alt="img"></p>
<p><strong>IDT</strong>表的每一项成员只要有效，都是一个函数。</p>
<h6 id="拆解中断门"><a href="#拆解中断门" class="headerlink" title="拆解中断门"></a>拆解中断门</h6><p><img src="https://s1.ax1x.com/2020/10/26/BuPaNR.png" alt="img"></p>
<p>中断门与调用门的结构基本一致，区别在于没有了参数部分和8-12位有一个位’D’来确定门的大小，当D为1 = 32位，当D为 0 = 16位。</p>
<h6 id="进入中断门"><a href="#进入中断门" class="headerlink" title="进入中断门"></a>进入中断门</h6><p>大家最熟知的<code>int3</code>中断指令就可以进入中断门，<code>int3</code>是Intel特意设计过的指令，他的硬编码为<code>CC</code>只占用了一个字节。</p>
<p>打开调试器输入<code>int3</code>可以看见硬编码为<code>CC</code></p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuAjwF.png" alt="img"></p>
<p>如果输入<code>int 3</code>在中间多加个空格硬编码就会变成<code>CD 03</code></p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuAXeU.png" alt="img"></p>
<p>这两种写法都代表<code>int3</code>中断。</p>
<p>但是除了<code>int3</code>其他中断就不可以这样写了，如<code>int 2</code>，调试器会直接提示无法识别。</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuVSHS.png" alt="img"></p>
<p>想要使用<code>int 2</code>必须要在中间加入空格</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuV0Cd.png" alt="img"></p>
<p><strong>int</strong>后面跟的123是<strong>IDT</strong>表的索引号，如<code>int 0</code>为<strong>IDT</strong>表的第一个元素。</p>
<p>在WinDbg中使用<code>!idt</code>命令可以查看idt表中每个元素对应的中断函数，如<code>!idt 3</code>查看<code>int3</code>的函数地址</p>
<p><img src="https://s1.ax1x.com/2020/10/26/Buub4S.png" alt="img"></p>
<p>为了证明这是int3的函数，使用bp对该函数下一个int3断点</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuK7rR.png" alt="img"></p>
<p>再在R3下设置一个int3，执行后CPU立马挂了，因为形成了递归中断。</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuMezQ.png" alt="img"></p>
<h6 id="使用中断门提权，并分析中断门"><a href="#使用中断门提权，并分析中断门" class="headerlink" title="使用中断门提权，并分析中断门"></a>使用中断门提权，并分析中断门</h6><p>我们先自己构造出一个中断门，首先定义一个函数，并得到他的地址。</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAJwa8.png" alt="img"></p>
<p>利用这个地址，构造一个中断门<code>0040ee00 00081000</code>，找到<strong>IDT</strong>表的空位写入，可以看到<strong>IDT</strong>表的0x100的位置是空的，我把值写到这。</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuJnht.png" alt="img"></p>
<p>写入</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuJNhq.png" alt="img"></p>
<p>编辑代码，因为int后面跟的是表项所以写0x20</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		iretd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Text func addr: %x\r\n&quot;</span>,test);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">0x20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后成功断下，证明成功进入中断门</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuD8z9.png" alt="img"></p>
<p>接下来在<code>int 0x20</code>处下一个断点，观察进入R0前的寄存器。</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuDWo8.png" alt="img"></p>
<p>这里我复制一份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPP</span><br><span class="line">EAX &#x3D; 00000000 EBX &#x3D; 7FFD8000 ECX &#x3D; 1379E52E EDX &#x3D; 003E33C8 ESI &#x3D; 0012FE64 EDI &#x3D; 0012FF30 EIP &#x3D; 00401061 ESP &#x3D; 0012FE64 EBP &#x3D; 0012FF30 EFL &#x3D; 00000246 </span><br><span class="line"></span><br><span class="line">CS &#x3D; 001B DS &#x3D; 0023 ES &#x3D; 0023 SS &#x3D; 0023 FS &#x3D; 003B GS &#x3D; 0000 </span><br><span class="line"></span><br><span class="line">OV &#x3D; 0 UP &#x3D; 0 EI &#x3D; 1 PL &#x3D; 0 ZR &#x3D; 1 AC &#x3D; 0 PE &#x3D; 1 CY &#x3D; 0 </span><br></pre></td></tr></table></figure>
<p>接着单步进入test函数触发int3断点，在WinDbg上查看R0的寄存器和栈，首先查看栈：</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BurH9e.png" alt="img"></p>
<p>栈顶被压入了五个值，分别是：</p>
<p>返回地址：0x0401063</p>
<p>R3的CS段：0x1b</p>
<p>R3的EFLAGS寄存器：0x346</p>
<p>R3ESP：0x012fe64</p>
<p>R3的SS段：0x23</p>
<p>查看寄存器</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BugesJ.png" alt="img"></p>
<p>可以看到，CS变成了8，SS变成了10，EFLAGS变成了46，fs变成了30（自动帮我们切换成了KPCR），由于他只帮我们切换到KPCR，没帮我们改回去，所以返回的时候可能会有异常。最好在进R0之前先保存一下fs。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) test()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		iretd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Text func addr: %x\r\n&quot;</span>,test);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push fs;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">0x20</span>;</span><br><span class="line">		pop fs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，调用门和中断门很像，而且都可以用来提权，那么两者的区别是什么呢？——<strong>屏蔽中断</strong></p>
<p>想要了解什么是<strong>屏蔽中断</strong>，需要先看一下EFLAGS的解析图：</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuIAKK.png" alt="img"></p>
<p>可以看到EFLAGS第九位为IF位（Interrupt Enable Flag）中断启用标志位，设置IF＝1，则允许中断；设置IF＝0，则禁止中断。</p>
<p>在刚刚R0寄存器的图片中可以看到，EFLAGS被修改成了46，转换为二进制<code>00 0100 0110</code>，第九位为0，所以屏蔽了中断。</p>
<p>除了进入中断门屏蔽中断外，还可以使用<code>cli</code>命令屏蔽中断。</p>
<ul>
<li>CLI (Clear Interrupt) 禁止中断发生</li>
<li>STI (Set Interrupt) 允许中断发生</li>
</ul>
<p>这两个指令只能在内核模式下执行，不可以在用户模式下执行；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">    cli;</span><br><span class="line">    xxxxxxxxxx;</span><br><span class="line">    xxxxxxxxxx;</span><br><span class="line">    sti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了IF位，进入中断门还会将VM（虚拟8086模式）、TF（单步位）、NT（任务嵌套位）位清空，以防止中断嵌套。</p>
<h5 id="陷阱门（Trap-Gate）"><a href="#陷阱门（Trap-Gate）" class="headerlink" title="陷阱门（Trap Gate）"></a>陷阱门（Trap Gate）</h5><p><img src="https://s1.ax1x.com/2020/10/27/BQeMrR.png" alt="img"></p>
<p>陷阱门与中断门基本一致，唯一的区别是陷阱门不会将IF位（中断启用标志位）清空，只会将VM（虚拟8086模式）、TF（单步位）、NT（任务嵌套位）位清空。</p>
<p>构造一个陷阱门<code>0040ef00 00081000</code></p>
<p>进入陷阱门后查看eflags寄存器</p>
<p><img src="https://s1.ax1x.com/2020/10/27/BleshT.png" alt="img"></p>
<p>246转换为二进制<code>10 0100 0110</code>IF位为1</p>
<h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><h6 id="任务段（TSS）"><a href="#任务段（TSS）" class="headerlink" title="任务段（TSS）"></a>任务段（TSS）</h6><p>任务段存在于GDT表中，使用<code>r tr</code>命令可查看任务段的段选择子。</p>
<p><img src="https://s1.ax1x.com/2020/10/28/B3GMY4.png" alt="img"></p>
<p>再到GDT表中找到0x28的位置，这个就是任务段。</p>
<p><img src="https://s1.ax1x.com/2020/10/28/B3GsXt.png" alt="img"></p>
<ul>
<li>任务段结构</li>
</ul>
<p>使用dt命令查看任务段结构</p>
<p><img src="https://s1.ax1x.com/2020/10/28/B3SOHS.png" alt="img"></p>
<p>Intel的白皮书上也有对任务段结构的描述图片</p>
<p><img src="https://s1.ax1x.com/2020/10/28/B3AHwq.png" alt="img"></p>
<p>当任务段切换之后，上一任务段的寄存器也被替换成当前任务段的寄存器，当通过<strong>Previous Task Link</strong>回到上一个任务段时，寄存器又会替换回去。因为这种操作效率太低，所以Windows、Linux等操作系统都没用使用到任务段。</p>
<ul>
<li>任务段描述符</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/28/B3laxx.png" alt="img"></p>
<p>任务段的描述符与数据段、代码段的差不多，不同的地方在：</p>
<ol>
<li>以为是系统段所以12为0</li>
<li>取消了D/B位</li>
<li>Type处有个B，这个位表示是否正忙（当前有没有被使用）</li>
</ol>
<p>使用<code>dg</code>命令可以自动解析段</p>
<p><img src="https://s1.ax1x.com/2020/10/28/B3U1Ln.png" alt="img"></p>
<p>使用<code>dt 结构 base</code>可以查看结构中的内容</p>
<p><img src="https://s1.ax1x.com/2020/10/28/B3arcQ.png" alt="img"></p>
<p>可以看到esp0为<code>0x83f28cb0</code> ss为<code>0x10</code>，当调用或中断门从R3切换到R0就会替换成这两个值。</p>
<ul>
<li>实现一个任务段</li>
</ul>
<p>注意！tss段的大小必须大于104字节！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> esp3[<span class="number">0x2000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> esp0[<span class="number">0x2000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		iretd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UCHAR DirectionMap[<span class="number">32</span>];                                                 <span class="comment">//0x0</span></span><br><span class="line">	UCHAR IoMap[<span class="number">8196</span>];                                                      <span class="comment">//0x20</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	USHORT Backlink;                                                        <span class="comment">//0x0</span></span><br><span class="line">	USHORT Reserved0;                                                       <span class="comment">//0x2</span></span><br><span class="line">	ULONG Esp0;                                                             <span class="comment">//0x4</span></span><br><span class="line">	USHORT Ss0;                                                             <span class="comment">//0x8</span></span><br><span class="line">	USHORT Reserved1;                                                       <span class="comment">//0xa</span></span><br><span class="line">	ULONG NotUsed1[<span class="number">4</span>];                                                      <span class="comment">//0xc</span></span><br><span class="line">	ULONG CR3;                                                              <span class="comment">//0x1c</span></span><br><span class="line">	ULONG Eip;                                                              <span class="comment">//0x20</span></span><br><span class="line">	ULONG EFlags;                                                           <span class="comment">//0x24</span></span><br><span class="line">	ULONG Eax;                                                              <span class="comment">//0x28</span></span><br><span class="line">	ULONG Ecx;                                                              <span class="comment">//0x2c</span></span><br><span class="line">	ULONG Edx;                                                              <span class="comment">//0x30</span></span><br><span class="line">	ULONG Ebx;                                                              <span class="comment">//0x34</span></span><br><span class="line">	ULONG Esp;                                                              <span class="comment">//0x38</span></span><br><span class="line">	ULONG Ebp;                                                              <span class="comment">//0x3c</span></span><br><span class="line">	ULONG Esi;                                                              <span class="comment">//0x40</span></span><br><span class="line">	ULONG Edi;                                                              <span class="comment">//0x44</span></span><br><span class="line">	USHORT Es;                                                              <span class="comment">//0x48</span></span><br><span class="line">	USHORT Reserved2;                                                       <span class="comment">//0x4a</span></span><br><span class="line">	USHORT Cs;                                                              <span class="comment">//0x4c</span></span><br><span class="line">	USHORT Reserved3;                                                       <span class="comment">//0x4e</span></span><br><span class="line">	USHORT Ss;                                                              <span class="comment">//0x50</span></span><br><span class="line">	USHORT Reserved4;                                                       <span class="comment">//0x52</span></span><br><span class="line">	USHORT Ds;                                                              <span class="comment">//0x54</span></span><br><span class="line">	USHORT Reserved5;                                                       <span class="comment">//0x56</span></span><br><span class="line">	USHORT Fs;                                                              <span class="comment">//0x58</span></span><br><span class="line">	USHORT Reserved6;                                                       <span class="comment">//0x5a</span></span><br><span class="line">	USHORT Gs;                                                              <span class="comment">//0x5c</span></span><br><span class="line">	USHORT Reserved7;                                                       <span class="comment">//0x5e</span></span><br><span class="line">	USHORT LDT;                                                             <span class="comment">//0x60</span></span><br><span class="line">	USHORT Reserved8;                                                       <span class="comment">//0x62</span></span><br><span class="line">	USHORT Flags;                                                           <span class="comment">//0x64</span></span><br><span class="line">	USHORT IoMapBase;                                                       <span class="comment">//0x66</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span> <span class="title">IoMaps</span>[1];</span>                                        <span class="comment">//0x68</span></span><br><span class="line">	UCHAR IntDirectionMap[<span class="number">32</span>];                                              <span class="comment">//0x208c</span></span><br><span class="line">&#125;KTSS,*PKTSS; </span><br><span class="line"></span><br><span class="line">KTSS tss = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(esp3,<span class="number">0xcc</span>,<span class="keyword">sizeof</span>(esp3));</span><br><span class="line">	<span class="built_in">memset</span>(esp0,<span class="number">0xcc</span>,<span class="keyword">sizeof</span>(esp0));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tss addr = %x\r\n&quot;</span>,&amp;tss);</span><br><span class="line"></span><br><span class="line">	tss.Eax =<span class="number">0</span>;</span><br><span class="line">	tss.Ecx =<span class="number">0</span>;</span><br><span class="line">	tss.Edx =<span class="number">0</span>;</span><br><span class="line">	tss.Ebx =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tss.Ebp =<span class="number">0</span>;</span><br><span class="line">	tss.Esi =<span class="number">0</span>;</span><br><span class="line">	tss.Edi =<span class="number">0</span>;</span><br><span class="line">	tss.Cs = <span class="number">0x8</span>;</span><br><span class="line">	tss.Ss = <span class="number">0x10</span>;</span><br><span class="line">	tss.Ds = <span class="number">0x23</span>;</span><br><span class="line">	tss.Es = <span class="number">0x23</span>;</span><br><span class="line">	tss.Fs = <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	tss.Esp =(ULONG)(esp3+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Esp0 =(ULONG)(esp0+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Ss = <span class="number">0x10</span>;</span><br><span class="line">	tss.Eip =(ULONG)test;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KTSS size:%x\r\n&quot;</span>,<span class="keyword">sizeof</span>(KTSS));</span><br><span class="line">	DWORD dwCr3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入CR3:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%x\n&quot;</span>,&amp;dwCr3);</span><br><span class="line">	tss.CR3 = dwCr3;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func addr = %x\r\n esp0 = %x\r\n esp3 = %x\r\n&quot;</span>,test,tss.Esp0,tss.Esp);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> bufcode[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		call fword ptr bufcode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获得tss段的地址0x409030，构造一个任务段描述符<code>0000e940 903020ac</code>。</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B8yCgP.png" alt="img"></p>
<p>将任务段描述符写入GDT表中0x48的位置</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B8yL2q.png" alt="img"></p>
<p>使用<code>!process 0 0</code>命令得到程序CR3（页表基址）</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B86iGR.png" alt="img"></p>
<p>输入CR3后确定值正常后回车</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B86ZqO.png" alt="img"></p>
<p>成功断下</p>
<p><img src="https://s1.ax1x.com/2020/10/26/BuD8z9.png" alt="img"></p>
<p>此时使用<code>r tr</code>命令查看断段选择子可以看见变成了0x48</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B86yLT.png" alt="img"></p>
<p>使用<code>dg tr</code>也可以看到变化</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B86ceU.png" alt="img"></p>
<p>寄存器也被替换成我设置好的值</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B86OFH.png" alt="img"></p>
<p>使用<strong>dt</strong>命令查看结构可以看见<strong>Previous Task Link</strong>从0变成了0x28</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B8cS6P.png" alt="img"></p>
<p>再查看0x28的结构，可以看到里面保存了切换到我们自己的任务段之前各个寄存器的值。</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B8celq.png" alt="img"></p>
<p>这段代码当走到<strong>iretd</strong>返回之后会蓝屏，因为<strong>test</strong>函数里使用了<code>int3</code>,而<code>int3</code>会将NT位（任务嵌套位）清空，而使用<strong>iretd</strong>进行返回的时候，<strong>iretd</strong>首先会查询当前有没有任务嵌套，也就是查看NT位。如果NT位为1，就会去找<strong>TSS</strong>的<strong>Backlink</strong>，拿到上一个任务的<strong>tr</strong>，然后替换寄存器返回。如果NT位为0，<strong>iretd</strong>会直接查栈的esp+0返回。在上面的代码里把esp都初始化为了0xcc，所以导致<strong>iretd</strong>返回到0xcc导致蓝屏。</p>
<p>修改test函数内代码防止蓝屏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CPP</span><br><span class="line">__declspec(naked) void test()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		int 3;</span><br><span class="line">		pushfd;</span><br><span class="line">		pop eax;</span><br><span class="line">		or eax,4000;</span><br><span class="line">		push eax;</span><br><span class="line">		popfd;</span><br><span class="line">		iretd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://zddr.net/2020/10/12/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-%E6%AE%B5/XXXXXXXXXXXXXXXXXXXXXXXX">^_^</a>:<br>注意 这里有可能导致蓝屏或cpu卡死的其他两点<br>test函数里的int3<br>28没用置为空闲<br>28cr3没有保存<br>还没空测试，先记着</p>
<h6 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h6><p><img src="https://s1.ax1x.com/2020/10/29/BGhwd0.png" alt="img"></p>
<p>需要注意的是，任务段是构建在<strong>GDT</strong>表中的，而任务门则需要构造在<strong>IDT</strong>表中。</p>
<p>先把<strong>任务段描述符</strong>写入<strong>GDT</strong>中的0x48位置</p>
<p><img src="https://s1.ax1x.com/2020/10/29/B8yL2q.png" alt="img"></p>
<p>接着构造任务门写入<strong>IDT</strong>表+0x100的位置中</p>
<p><img src="https://s1.ax1x.com/2020/10/29/BJF6Ld.png" alt="img"></p>
<p>修改代码,将call改为int</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> esp3[<span class="number">0x2000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> esp0[<span class="number">0x2000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">3</span>;</span><br><span class="line">		pushfd;</span><br><span class="line">		pop eax;</span><br><span class="line">		<span class="keyword">or</span> eax,<span class="number">4000</span>;</span><br><span class="line">		push eax;</span><br><span class="line">		popfd;</span><br><span class="line">		iretd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UCHAR DirectionMap[<span class="number">32</span>];                                                 <span class="comment">//0x0</span></span><br><span class="line">	UCHAR IoMap[<span class="number">8196</span>];                                                      <span class="comment">//0x20</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KTSS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	USHORT Backlink;                                                        <span class="comment">//0x0</span></span><br><span class="line">	USHORT Reserved0;                                                       <span class="comment">//0x2</span></span><br><span class="line">	ULONG Esp0;                                                             <span class="comment">//0x4</span></span><br><span class="line">	USHORT Ss0;                                                             <span class="comment">//0x8</span></span><br><span class="line">	USHORT Reserved1;                                                       <span class="comment">//0xa</span></span><br><span class="line">	ULONG NotUsed1[<span class="number">4</span>];                                                      <span class="comment">//0xc</span></span><br><span class="line">	ULONG CR3;                                                              <span class="comment">//0x1c</span></span><br><span class="line">	ULONG Eip;                                                              <span class="comment">//0x20</span></span><br><span class="line">	ULONG EFlags;                                                           <span class="comment">//0x24</span></span><br><span class="line">	ULONG Eax;                                                              <span class="comment">//0x28</span></span><br><span class="line">	ULONG Ecx;                                                              <span class="comment">//0x2c</span></span><br><span class="line">	ULONG Edx;                                                              <span class="comment">//0x30</span></span><br><span class="line">	ULONG Ebx;                                                              <span class="comment">//0x34</span></span><br><span class="line">	ULONG Esp;                                                              <span class="comment">//0x38</span></span><br><span class="line">	ULONG Ebp;                                                              <span class="comment">//0x3c</span></span><br><span class="line">	ULONG Esi;                                                              <span class="comment">//0x40</span></span><br><span class="line">	ULONG Edi;                                                              <span class="comment">//0x44</span></span><br><span class="line">	USHORT Es;                                                              <span class="comment">//0x48</span></span><br><span class="line">	USHORT Reserved2;                                                       <span class="comment">//0x4a</span></span><br><span class="line">	USHORT Cs;                                                              <span class="comment">//0x4c</span></span><br><span class="line">	USHORT Reserved3;                                                       <span class="comment">//0x4e</span></span><br><span class="line">	USHORT Ss;                                                              <span class="comment">//0x50</span></span><br><span class="line">	USHORT Reserved4;                                                       <span class="comment">//0x52</span></span><br><span class="line">	USHORT Ds;                                                              <span class="comment">//0x54</span></span><br><span class="line">	USHORT Reserved5;                                                       <span class="comment">//0x56</span></span><br><span class="line">	USHORT Fs;                                                              <span class="comment">//0x58</span></span><br><span class="line">	USHORT Reserved6;                                                       <span class="comment">//0x5a</span></span><br><span class="line">	USHORT Gs;                                                              <span class="comment">//0x5c</span></span><br><span class="line">	USHORT Reserved7;                                                       <span class="comment">//0x5e</span></span><br><span class="line">	USHORT LDT;                                                             <span class="comment">//0x60</span></span><br><span class="line">	USHORT Reserved8;                                                       <span class="comment">//0x62</span></span><br><span class="line">	USHORT Flags;                                                           <span class="comment">//0x64</span></span><br><span class="line">	USHORT IoMapBase;                                                       <span class="comment">//0x66</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">KiIoAccessMap</span> <span class="title">IoMaps</span>[1];</span>                                        <span class="comment">//0x68</span></span><br><span class="line">	UCHAR IntDirectionMap[<span class="number">32</span>];                                              <span class="comment">//0x208c</span></span><br><span class="line">&#125;KTSS,*PKTSS; </span><br><span class="line"></span><br><span class="line">KTSS tss = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(esp3,<span class="number">0xcc</span>,<span class="keyword">sizeof</span>(esp3));</span><br><span class="line">	<span class="built_in">memset</span>(esp0,<span class="number">0xcc</span>,<span class="keyword">sizeof</span>(esp0));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tss addr = %x\r\n&quot;</span>,&amp;tss);</span><br><span class="line"></span><br><span class="line">	tss.Eax =<span class="number">0</span>;</span><br><span class="line">	tss.Ecx =<span class="number">0</span>;</span><br><span class="line">	tss.Edx =<span class="number">0</span>;</span><br><span class="line">	tss.Ebx =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tss.Ebp =<span class="number">0</span>;</span><br><span class="line">	tss.Esi =<span class="number">0</span>;</span><br><span class="line">	tss.Edi =<span class="number">0</span>;</span><br><span class="line">	tss.Cs = <span class="number">0x8</span>;</span><br><span class="line">	tss.Ss = <span class="number">0x10</span>;</span><br><span class="line">	tss.Ds = <span class="number">0x23</span>;</span><br><span class="line">	tss.Es = <span class="number">0x23</span>;</span><br><span class="line">	tss.Fs = <span class="number">0x30</span>;</span><br><span class="line"></span><br><span class="line">	tss.Esp =(ULONG)(esp3+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Esp0 =(ULONG)(esp0+<span class="number">0x2000</span><span class="number">-8</span>);</span><br><span class="line">	tss.Ss = <span class="number">0x10</span>;</span><br><span class="line">	tss.Eip =(ULONG)test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KTSS size:%x\r\n&quot;</span>,<span class="keyword">sizeof</span>(KTSS));</span><br><span class="line">	DWORD dwCr3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入CR3:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>,&amp;dwCr3);</span><br><span class="line">	tss.CR3 = dwCr3;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;func addr = %x\r\n esp0 = %x\r\n esp3 = %x\r\n&quot;</span>,test,tss.Esp0,tss.Esp);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> bufcode[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="number">0x20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码，成功进入任务门</p>
<p><img src="https://s1.ax1x.com/2020/10/29/BJk2X4.png" alt="img"></p>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><blockquote>
<p>《牛逼的火哥》</p>
</blockquote>
<blockquote>
<p>《IA-32卷3：系统编程指南》(中文版)</p>
</blockquote>
<blockquote>
<p>《火哥4合1的intel手册》</p>
</blockquote>
<blockquote>
<p>以及<a target="_blank" rel="noopener" href="https://www.cnblogs.com/onetrainee/">OneTrainee</a>大佬的博客</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ZDDR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zddr.net/2020/10/12/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E6%AE%B5/">https://zddr.net/2020/10/12/x86内核-保护模式--段/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zddr.net" target="_blank">ZDDR's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.ax1x.com/2020/02/11/1oFBM8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/29/x86%E5%86%85%E6%A0%B8-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F--%E9%A1%B5/"><img class="prev-cover" src="https://s2.ax1x.com/2020/02/11/1oFBM8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">x86内核-保护模式--页</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/15/Windows%20SDK/"><img class="next-cover" src="https://s1.ax1x.com/2020/09/17/wWSbKs.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DirectX SDK学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">双机调试环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bcdedit%E6%B7%BB%E5%8A%A0%E8%B0%83%E8%AF%95%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">bcdedit添加调试启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E5%BD%93%E5%89%8D%E5%90%AF%E5%8A%A8%E9%A1%B9"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">拷贝当前启动项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%BD%93%E5%89%8D%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%E6%9C%AB%E5%B0%BE"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">将启动项添加到当前启动顺序末尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E8%B0%83%E8%AF%95%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">设置全局调试参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E5%BC%95%E5%AF%BC%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">启用引导的调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">启用操作系统的调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E4%B8%BA30%E7%A7%92"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">设置等待时间为30秒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">实体机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinDbg%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">WinDbg的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinDbg-Preview%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.</span> <span class="toc-text">WinDbg Preview的配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">保护模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是保护模式？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-number">3.</span> <span class="toc-text">段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">什么是段?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTEB%E3%80%81PEB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFKPCR%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">什么是TEB、PEB？什么是KPCR？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%AF%8F%E4%B8%AA%E6%AE%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">验证每个段的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ds"><span class="toc-number">3.3.1.</span> <span class="toc-text">ds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ss"><span class="toc-number">3.3.2.</span> <span class="toc-text">ss</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cs"><span class="toc-number">3.3.3.</span> <span class="toc-text">cs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs"><span class="toc-number">3.3.4.</span> <span class="toc-text">fs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">3.4.</span> <span class="toc-text">段选择子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">什么是段选择子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E4%BB%8516%E4%BD%8D%E7%9A%84%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90%E6%98%AF%E5%A6%82%E4%BD%95%E5%8C%85%E5%90%AB%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BF%A1%E6%81%AF%E7%9A%84%EF%BC%9F"><span class="toc-number">3.4.2.</span> <span class="toc-text">一个长度仅16位的段选择子是如何包含这么多信息的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">3.4.3.</span> <span class="toc-text">拆分段选择子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDT-Global-Descriptor-Table-%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">GDT(Global Descriptor Table)全局描述符表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BGDT%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.5.1.</span> <span class="toc-text">查看GDT寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BGDT%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.5.2.</span> <span class="toc-text">查看GDT表的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BGDT%E8%A1%A8%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">3.5.3.</span> <span class="toc-text">查看GDT表的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8R3%E4%B8%8B%E8%8E%B7%E5%8F%96GDT%E8%A1%A8"><span class="toc-number">3.5.4.</span> <span class="toc-text">在R3下获取GDT表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.6.</span> <span class="toc-text">段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.6.1.</span> <span class="toc-text">拆解数据、代码段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AD%E5%90%84%E4%B8%AA%E6%A0%87%E5%BF%97%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.6.2.</span> <span class="toc-text">数据、代码段描述符中各个标志的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P-%EF%BC%88%E6%AE%B5%E5%AD%98%E5%9C%A8%EF%BC%89%E6%A0%87%E5%BF%97"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">P （段存在）标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#S%EF%BC%88%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B%EF%BC%89%E6%A0%87%E5%BF%97"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">S（描述符类型）标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit%EF%BC%88%E6%AE%B5%E9%99%90%E9%95%BF%EF%BC%89%E6%A0%87%E5%BF%97"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">limit（段限长）标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Base%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%9F%9F"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">Base基地址域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G%EF%BC%88%E7%B2%92%E5%BA%A6%EF%BC%89%E6%A0%87%E5%BF%97"><span class="toc-number">3.6.2.5.</span> <span class="toc-text">G（粒度）标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TYPE%E5%9F%9F"><span class="toc-number">3.6.2.6.</span> <span class="toc-text">TYPE域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-B%E6%A0%87%E5%BF%97"><span class="toc-number">3.6.2.7.</span> <span class="toc-text">D&#x2F;B标志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#D"><span class="toc-number">3.6.2.7.1.</span> <span class="toc-text">D</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B"><span class="toc-number">3.6.2.7.2.</span> <span class="toc-text">B</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DPL%EF%BC%88Descriptor-Privilege-Level%EF%BC%89%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="toc-number">3.6.2.8.</span> <span class="toc-text">DPL（Descriptor Privilege Level）描述符特权级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.6.2.8.1.</span> <span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">3.6.2.8.2.</span> <span class="toc-text">代码段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E8%A7%A3%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.6.3.</span> <span class="toc-text">拆解系统描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">门描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%97%A8%EF%BC%88Call-Gate%EF%BC%89"><span class="toc-number">3.6.3.1.1.</span> <span class="toc-text">调用门（Call Gate）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%97%A8%EF%BC%88Interrupt-Gate%EF%BC%89"><span class="toc-number">3.6.3.1.2.</span> <span class="toc-text">中断门（Interrupt Gate）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="toc-number">3.6.3.1.2.1.</span> <span class="toc-text">什么是中断？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IDT%E8%A1%A8%EF%BC%88Interrupt-Descriptor-Table%EF%BC%89%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">3.6.3.1.2.2.</span> <span class="toc-text">IDT表（Interrupt Descriptor Table）中断描述符表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%86%E8%A7%A3%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="toc-number">3.6.3.1.2.3.</span> <span class="toc-text">拆解中断门</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="toc-number">3.6.3.1.2.4.</span> <span class="toc-text">进入中断门</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%90%E6%9D%83%EF%BC%8C%E5%B9%B6%E5%88%86%E6%9E%90%E4%B8%AD%E6%96%AD%E9%97%A8"><span class="toc-number">3.6.3.1.2.5.</span> <span class="toc-text">使用中断门提权，并分析中断门</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%B7%E9%98%B1%E9%97%A8%EF%BC%88Trap-Gate%EF%BC%89"><span class="toc-number">3.6.3.1.3.</span> <span class="toc-text">陷阱门（Trap Gate）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.6.3.1.4.</span> <span class="toc-text">任务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%AE%B5%EF%BC%88TSS%EF%BC%89"><span class="toc-number">3.6.3.1.4.1.</span> <span class="toc-text">任务段（TSS）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%97%A8"><span class="toc-number">3.6.3.1.4.2.</span> <span class="toc-text">任务门</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">4.</span> <span class="toc-text">References:</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://s2.ax1x.com/2020/02/11/1oFBM8.png)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By ZDDR</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>